---
type: claude-knowledge
source: aiprojects
source_path: "knowledge/notes/research-beads-federation-cross-instance.md"
source_category: "session-knowledge"
synced: 2026-02-17
title: "Research: Beads Federation / Cross-Instance Task Handoff"
tags:
  - claude-knowledge
  - session-knowledge
---

# Research: Beads Federation / Cross-Instance Task Handoff

**Date**: 2026-02-10
**Status**: Conceptual / Not yet scoped for development
**Related**: AIfred, Beads task management
**Beads Task**: None yet (create when ready to develop)

---

## Problem Statement

When multiple AIfred instances exist (e.g., dev and prod), there's no mechanism for one instance to create tasks in another instance's Beads database. A developer finishing work in a dev instance has no automated path to signal the prod instance that something needs deployment, verification, or monitoring setup.

## Concept

Two (or more) AIfred instances, each with their own Claude Code environment and `.beads/` database, communicating through a shared task exchange mechanism.

```
┌─────────────────────┐          ┌─────────────────────┐
│  AIfred:dev          │          │  AIfred:prod         │
│  ┌───────────────┐   │  task    │  ┌───────────────┐   │
│  │ .beads/       │───┼─────────┼──│ .beads/       │   │
│  │ (local DB)    │   │ exchange │  │ (local DB)    │   │
│  └───────────────┘   │         │  └───────────────┘   │
│                      │         │                      │
│  Claude Code session │         │  Headless Claude     │
│  (human-driven dev)  │         │  (cron-based pickup) │
└─────────────────────┘          └─────────────────────┘
```

### Example Lifecycle

1. Developer works in AIfred:dev, finishes a feature
2. Dev pushes to `main` / tags a release
3. Dev instance exports a task to a shared inbox
4. AIfred:prod's cron detects the new inbound task, imports to local Beads
5. Prod Claude picks it up — runs deployment verification, monitoring setup, logging checks
6. Optionally: prod sends acknowledgment back ("deployed" or "failed — needs fix")

### Desired Capabilities

- `bd export` with targeting (tag tasks for a destination instance)
- Shared filesystem inbox (simplest transport for same-machine instances)
- Cron-based polling on the receiving side
- Task metadata carrying: source instance, git ref, PR link, workflow to execute
- Potentially bidirectional (prod can send back to dev)

## Existing Primitives (Already in Beads)

| Primitive | Status | Notes |
|-----------|--------|-------|
| `bd export --format jsonl` | Works | Serialize tasks to portable files |
| `bd import -i file.jsonl --dedupe-after` | Works | Import from external JSONL |
| `metadata` field | Works | Arbitrary JSON — can carry source instance, git refs |
| `external_ref` field | Works | Link to external systems |
| Hash-based IDs | Works | Prevent conflicts between instances |
| `bd federation` command | Exists but requires Dolt backend (CGO build, not in npm) | Official federation is planned |
| `labels` | Works | Can tag tasks with `target:prod`, `source:dev`, etc. |

### Minimal Working Example (No New Code)

```bash
# Dev side: export tasks tagged for prod
bd export --format jsonl --label target:prod --status open \
  -o /shared/aifred-inbox/prod/$(date +%s).jsonl

# Prod side (cron): import and process
for f in /shared/aifred-inbox/prod/*.jsonl; do
  bd import -i "$f" --dedupe-after && mv "$f" "$f.processed"
done
```

~10 lines of bash using existing Beads commands. No wrapper CLI needed.

## Design Review Findings

### What Works About This Concept

- Beads export/import primitives already exist
- JSONL is a clean, human-readable exchange format
- Metadata field can carry all cross-instance context needed
- Hash-based IDs naturally prevent conflicts
- Aligns with AIfred's profile system (dev profile vs. prod profile)

### Challenges and Risks Identified

**1. CI/CD Overlap**
The dev→tag→deploy→verify workflow overlaps heavily with GitHub Actions + deployment environments. Key question: **What requires AI judgment vs. deterministic automation?** If prod verification is just "run health checks," that's a CI/CD job, not a Beads task. If it's "Claude, look at this deployment and make sure monitoring covers the new endpoints" — that's where cross-instance Beads adds value.

**2. "Multiple Developers" Changes Scope**
Original concept: two instances. But multiple developers pushing to production means:
- N dev instances → 1 prod instance
- Concurrent writes to shared inbox (race conditions)
- Identity management for N developers
- Access control (who can push to prod?)
- This shifts from "filesystem inbox" to "message broker" territory

**3. Signing is Premature**
For same-machine instances, filesystem permissions + git author identity are sufficient. Crypto signing solves a threat model that doesn't exist yet. If cross-machine communication is needed later, HTTPS/mTLS is the right answer — not filesystem-level signing.

**4. Official Beads Federation**
`bd federation` exists as a command targeting the Dolt backend. Building a custom wrapper now may create technical debt if official federation ships. Check Beads roadmap before committing.

**5. Transport is Easy; Workflow is Hard**
Moving JSONL files between directories is trivial. The real design work is:
- **Workflow definition**: What does prod DO when it receives a "deploy" task?
- **State machine**: Created → Sent → Received → In Progress → Completed → Acknowledged
- **Failure handling**: Deploy fails — manual intervention? Auto-retry? Notify dev?
- **Idempotency**: Same task sent twice — how is this handled?

### Core Design Question

> Is the real value in **Beads talking to Beads**, or in **Claude instances coordinating work**?

If Beads-to-Beads: you're building a distributed task queue (many off-the-shelf options exist).
If Claude-to-Claude: the task exchange is the easy part — the hard part is the **AIfred prod profile** knowing what to do when it receives a deployment task. That's workflow design inside AIfred, not Beads infrastructure.

## Recommended Development Path (When Ready)

| Phase | What | Investment |
|-------|------|------------|
| **0: Design doc** | Write exact workflows end-to-end. "Dev finishes feature X. Then what happens step by step until prod is verified?" | Low (document only) |
| **1: Bash scripts** | `aifred-handoff.sh` wrapping `bd export` + filesystem + `bd import`. Single dev → single prod. | Low (~10 lines bash) |
| **2: AIfred integration** | Add handoff awareness to AIfred cron jobs and hooks. Prod-profile hooks detect imported tasks and trigger verification workflows. | Medium |
| **3: Multi-dev** | Add `source_instance` metadata, dedup logic, access control. Evaluate whether Beads Dolt federation is ready. | High |

## Task Metadata Schema (Draft)

When a task is sent cross-instance, the `metadata` field should carry:

```json
{
  "source_instance": "aifred-dev-01",
  "target_instance": "aifred-prod",
  "git_ref": "v1.2.3",
  "git_sha": "abc123def",
  "pr_url": "https://github.com/user/repo/pull/42",
  "project_name": "my-service",
  "workflow": "deploy-verify",
  "sent_at": "2026-02-10T15:30:00Z",
  "sent_by": "david"
}
```

## Open Questions

1. Does the Beads Dolt federation roadmap cover this use case? (Check before building custom)
2. What specific prod-side workflows require AI judgment vs. deterministic scripting?
3. Is same-machine deployment the only target, or will cross-machine be needed?
4. How does this interact with AIfred's existing profile system (dev profile vs. prod profile)?
5. Should the handoff trigger on git tag, manual command, or task label?

## References

- Beads CLI: `bd --help`, `bd export --help`, `bd import --help`
- Beads deep dive: `knowledge/notes/research-beads-deep-dive.md`
- AIfred project: `~/Code/AIfred/`
- AIfred context: `.claude/context/projects/` (AIfred entries)
- Headless Claude jobs: `.claude/jobs/registry.yaml`
