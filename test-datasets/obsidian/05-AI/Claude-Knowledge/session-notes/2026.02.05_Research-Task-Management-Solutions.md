---
type: claude-knowledge
source: aiprojects
source_path: "knowledge/notes/research-task-management-solutions.md"
source_category: "session-knowledge"
synced: 2026-02-17
title: "Research: Task & Project Management for AI Coding Agents"
tags:
  - claude-knowledge
  - session-knowledge
---

# Research: Task & Project Management for AI Coding Agents

**Date**: 2026-02-05
**Status**: Research Complete
**Decision**: Pending - See Recommendations

## Context

Evaluated tools and approaches for managing tasks/projects when working with Claude Code CLI, specifically solutions that allow a human to visually track, prioritize, organize, and add tasks **without burning AI tokens**. Our current setup uses a custom YAML-based orchestration system with built-in TaskCreate/TaskUpdate tools.

### Pain Points Driving This Research

1. Hard for a human to quickly see what is active, started, or done
2. Sessions disconnect and context is lost about why tasks were added
3. Multiple parallel sessions can conflict
4. Managing priorities across many domains requires recalling context
5. Viewing/managing tasks currently requires opening a Claude session (burns tokens)

## Landscape Overview

The AI coding task management space has exploded in 2025-2026. Tools fall into several categories:

| Category | Token Cost | Human Visibility | AI Integration | Examples |
|----------|-----------|-----------------|----------------|----------|
| AI-native orchestrators | High | High (web/TUI) | Deep | Vibe Kanban, Spec-Kitty |
| Git-backed issue trackers | Low | Medium (CLI/TUI) | Deep | Beads, Tracer, Trekker |
| GitHub Issues bridges | None for viewing | High (GitHub UI) | Medium | CCPM |
| File-based markdown | None for viewing | Medium (editor) | Medium | ROADMAP.md, planning-with-files |
| MCP task servers | Medium | Low (AI-only) | Deep | Claude Task Master |
| Traditional CLI tools | None | Medium (CLI/TUI) | Low (hookable) | Taskwarrior, kanban-tui |
| Obsidian-based | None | High (GUI) | Low | Obsidian Kanban, Task Board |

---

## Category 1: AI-Native Orchestrators (Web/TUI Dashboard)

### Vibe Kanban (github.com/BloopAI/vibe-kanban)

**Stats**: 20,593 stars | TypeScript/Rust | Apache-2.0

**Approach**: Terminal-based Kanban board with web dashboard that orchestrates AI coding agents. Each task runs in its own git worktree. Built-in diff review, PR creation, and parallel execution.

**Pros**:
- Visual Kanban board with real-time task status (no tokens to view)
- Parallel agent execution with git worktree isolation
- Built-in code review interface (diff viewer)
- Supports Claude Code, Gemini CLI, Cursor Agent, and others
- Rust backend (fast), TypeScript/React frontend
- Active development, strong community

**Cons**:
- Heavy tool -- full orchestration platform, not just task management
- Requires running a local server (Rust backend + React frontend)
- Opinionated about workflow (kanban-centric)
- Starting agents through the tool still burns tokens

**Grade**: A- (for visibility and orchestration; heavy for just task viewing)

---

### Spec-Kitty (github.com/Priivacy-ai/spec-kitty)

**Stats**: 553 stars | Python | MIT

**Approach**: Spec-driven development platform with live Kanban dashboard. Structures work as specs, plans, and work packages. Real-time tracking of multi-agent workflows.

**Pros**:
- Live web dashboard with Kanban tracking (no tokens to view status)
- Spec-driven: enforces specification-first development
- Git worktrees per work package
- Auto-merge capabilities
- Supports Claude, Cursor, Gemini, Codex
- JSON output for all commands (scriptable)

**Cons**:
- Newer project, smaller community
- Requires adopting spec-driven workflow
- Python CLI dependency
- Dashboard requires running a local server

**Grade**: B+ (strong spec-driven approach with good visibility)

---

### Ralph TUI (github.com/subsy/ralph-tui)

**Stats**: 1,721 stars | TypeScript | MIT

**Approach**: Terminal UI that connects AI coding agents to task trackers and runs them in autonomous loops. Selects highest-priority task, builds prompt, executes agent, detects completion, repeats.

**Pros**:
- TUI interface for monitoring agent progress
- Integrates with multiple task backends (prd.json, Beads)
- State persistence between runs (pause/resume)
- Handlebars templates for customizing agent prompts
- Agent-agnostic (Claude Code, OpenCode, Gemini CLI, etc.)

**Cons**:
- Focused on autonomous execution, not human task management
- Task creation still happens in the tracker (not in Ralph itself)
- Requires Bun runtime
- Less useful for manual task organization/prioritization

**Grade**: B (good for autonomous loops, limited for human task management)

---

## Category 2: Git-Backed Issue Trackers (Agent-Optimized)

### Beads (github.com/steveyegge/beads)

**Stats**: 15,095 stars | Go | MIT

**Approach**: Distributed, git-backed graph issue tracker. Issues stored as JSONL in `.beads/`, versioned with git. SQLite local cache for speed. Dependency-aware DAG with semantic memory decay.

**Pros**:
- Zero token cost to view/manage tasks (pure CLI: `bd list`, `bd show`)
- Git IS the database -- no server, no external dependencies
- Dependency graph with auto-ready task detection
- Hash-based IDs prevent merge conflicts in multi-agent workflows
- Stealth mode (local-only, no commits to shared repo)
- Contributor mode (separate repo for planning)
- Strong ecosystem: beads_viewer TUI, MCP integration, Rust port

**Cons**:
- CLI-first -- no built-in visual dashboard (need beads_viewer for TUI)
- Learning curve for the graph/dependency model
- Git merge of JSONL can be complex in edge cases
- Go runtime dependency

**Grade**: A (best balance of agent integration and human CLI access)

---

### Beads Viewer (github.com/Dicklesworthstone/beads_viewer)

**Stats**: 1,197 stars | Go | MIT

**Approach**: High-performance TUI for browsing Beads projects. Kanban board, dependency graph visualization, sprint dashboard with burndown charts, agent attribution.

**Pros**:
- Zero token cost -- pure terminal viewer
- Kanban board view with swimlanes
- Dependency graph visualization (highlights bottlenecks, cycles)
- Sprint dashboard with burndown charts
- Vim-style navigation, 60fps rendering (Bubble Tea)
- Agent attribution tracking

**Cons**:
- Only works with Beads (not standalone)
- Requires Go/Homebrew installation
- Relatively new, fast-moving

**Grade**: A- (the missing visual layer for Beads)

---

### Tracer (github.com/Abil-Shrestha/tracer)

**Stats**: 17 stars | Rust | MIT

**Approach**: CLI-first issue tracker with dependency tracking (blocks, parent-child, related, discovered-from) and multi-agent coordination via comments and auto-assign.

**Pros**:
- Lightweight, Rust-based CLI
- Rich dependency model
- Multi-agent coordination features
- MIT licensed

**Cons**:
- Very early stage (17 stars)
- Small community, uncertain maintenance
- Limited documentation

**Grade**: C+ (interesting concepts but too early)

---

### Trekker (github.com/obsfx/trekker)

**Stats**: 21 stars | TypeScript | MIT

**Approach**: CLI issue tracker using SQLite (via Bun). Tasks, epics, subtasks, dependencies. MCP server integration. Token-efficient TOON output format for agents.

**Pros**:
- MCP server for direct Claude Code integration
- Token-efficient serialization format (--toon flag)
- Full-text search (FTS5)
- Epics, subtasks, dependencies, comments

**Cons**:
- Very early stage (21 stars)
- Requires Bun runtime
- No visual interface
- Small community

**Grade**: C+ (interesting MCP integration, too early)

---

### Issue-Queue (github.com/rodmena-limited/issue-queue)

**Stats**: 9 stars | Python | Apache-2.0

**Approach**: Zero-dependency CLI issue tracker with agent context, lessons learned, tagging, dependencies, time tracking, code references, and audit logging.

**Pros**:
- Zero external dependencies
- Built-in time tracking and audit log
- Lessons-learned tracking
- Code reference attachment (file + line number)

**Cons**:
- Extremely early (9 stars)
- No visual interface
- Python-only
- Minimal community

**Grade**: C (good feature ideas, too early to adopt)

---

## Category 3: GitHub Issues Bridges

### CCPM - Claude Code Project Manager (github.com/automazeio/ccpm)

**Stats**: 7,043 stars | Shell | MIT

**Approach**: Uses GitHub Issues as the source of truth for task management. Git worktrees for parallel agent execution. Every commit tied to acceptance criteria in issues.

**Pros**:
- Zero token cost to view tasks (use GitHub web UI or `gh` CLI)
- Leverages existing GitHub Issues infrastructure
- Team visibility -- anyone with repo access sees progress
- Parallel execution with git worktrees
- Issue comments show real-time AI progress
- Shell-based (no runtime dependencies)

**Cons**:
- Requires GitHub (not useful for local-only projects)
- GitHub Issues UI is limited for complex project management
- Overhead of managing issues for small tasks
- Shell scripts can be fragile

**Grade**: A- (excellent for GitHub-centric workflows with team visibility)

---

## Category 4: MCP Task Management Servers

### Claude Task Master (github.com/eyaltoledano/claude-task-master)

**Stats**: 25,313 stars | JavaScript | Proprietary License

**Approach**: AI-powered task management via MCP server. Breaks PRDs into structured tasks. 7-36 tools depending on configuration. Perplexity AI integration for research-backed subtask generation.

**Pros**:
- Most popular tool in the space (25k+ stars)
- Deep MCP integration (works inside Claude Code, Cursor, etc.)
- PRD-to-tasks workflow
- Dependency tracking and analysis
- Multiple tool tiers (Core/Standard/All)
- Research-backed subtask generation

**Cons**:
- **Every interaction burns AI tokens** (MCP tools require AI session)
- No standalone human-readable dashboard
- Task data stored as JSON (not easy to browse manually)
- Proprietary license (not fully open source)
- Designed for AI-first interaction, not human browsing

**Grade**: B (excellent for AI-driven planning, poor for token-free human viewing)

---

### Claude Code Native Tasks (~/.claude/tasks/)

**Approach**: Built into Claude Code 2.1+ (January 2026). Replaced legacy Todos with persistent Tasks. Supports DAG dependencies, multi-session coordination, subagent spawning.

**Pros**:
- Zero setup (built into Claude Code)
- Persistent across sessions (~/.claude/tasks/)
- DAG-based dependency management
- Multi-session broadcasting (tasks update across sessions)
- Subagent coordination built-in

**Cons**:
- **Requires Claude session to view/manage** (tokens burned)
- No external viewer or dashboard
- Tasks stored in opaque format
- No human-friendly list view outside Claude
- Limited prioritization/organization features

**Grade**: B- (good for in-session coordination, fails the "no tokens to view" requirement)

---

## Category 5: File-Based Markdown Approaches

### Planning-with-Files (github.com/OthmanAdi/planning-with-files)

**Stats**: 13,143 stars | Python | MIT

**Approach**: Claude Code skill implementing Manus-style persistent markdown planning. Uses task_plan.md, progress.md, and findings.md as working memory. Principle: context window is RAM, filesystem is disk.

**Pros**:
- Zero token cost to view (just read markdown files)
- Simple, understandable format (markdown)
- Session recovery when context limits are reached
- Plugin marketplace installation
- 13k+ stars shows strong adoption

**Cons**:
- No visual dashboard (just markdown files)
- Requires manual reading of files for status overview
- Limited structured querying (no filters, no search)
- Can become unwieldy for large projects

**Grade**: B+ (excellent philosophy, limited visibility features)

---

### ROADMAP.md Convention

**Approach**: Structured markdown file with checkbox tracking. `[ ]` = Todo, `[-]` = In Progress (with start date), `[x]` = Completed (with completion date). Detailed task specs in `/tasks/` directory.

**Pros**:
- Zero token cost to view
- Simple, universal format
- Works with any editor (Obsidian, VS Code, vim)
- Git-tracked (full history)
- Claude Code can maintain it directly

**Cons**:
- No filtering, sorting, or querying
- Flat structure doesn't scale beyond ~50 tasks
- No dependency tracking
- No multi-domain organization (single file)

**Grade**: B (great for small projects, doesn't scale)

---

### ai-dev-tasks (github.com/snarktank/ai-dev-tasks)

**Stats**: 7,445 stars | Markdown-only | Apache-2.0

**Approach**: Pure markdown templates for structuring AI development. Three files: create-prd.md (PRD generation), generate-tasks.md (task breakdown), process-task-list.md (execution workflow).

**Pros**:
- Zero dependencies (just markdown files)
- Works with any AI coding assistant
- Clear progress tracking via task list checkboxes
- Simple adoption (copy files into project)

**Cons**:
- Just templates, not a tool (no automation)
- No dashboard or querying
- Manual process throughout
- No dependency or priority management

**Grade**: B- (good starting point, not a management system)

---

### Agentic Project Management (github.com/sdi2200262/agentic-project-management)

**Stats**: 1,967 stars | JavaScript | Custom License

**Approach**: Framework with Manager and Implementation Agents, Memory Banks, and Handover Protocols. File-based persistence with structured task assignment and review cycles.

**Pros**:
- Structured multi-agent workflow (manager/implementer roles)
- Memory banks with file-based persistence
- Handover protocols for session continuity
- Works with Claude Code, Cursor, GitHub Copilot

**Cons**:
- Complex setup and mental model
- Still requires AI sessions to interact
- Framework more than tool
- Custom license

**Grade**: B (strong architecture pattern, heavy for simple task tracking)

---

## Category 6: Traditional CLI/TUI Tools

### Taskwarrior (github.com/GothenburgBitFactory/taskwarrior)

**Stats**: 5,517 stars | C++ | MIT

**Approach**: The venerable CLI task manager. Feature-rich with projects, tags, priorities, dependencies, recurrence, hooks, and extensive querying/filtering.

**Pros**:
- Zero token cost (pure CLI)
- Extremely powerful filtering and reporting
- Hook system for automation (can trigger on task events)
- Extensive ecosystem (taskwarrior-tui, timewarrior, etc.)
- Data stored as plain text (easy to parse/script)
- 20+ years of maturity and stability
- UDA (User Defined Attributes) for custom fields

**Cons**:
- No native AI/agent integration (would need custom hooks)
- Steep learning curve
- Sync requires taskserver or third-party solutions
- TUI is a separate project (taskwarrior-tui)
- No native web dashboard

**Potential for our use case**: High -- hook scripts could bridge Claude Code tasks to Taskwarrior. Script reads YAML/JSON task output from Claude, creates/updates Taskwarrior tasks. Human views via `task` CLI or taskwarrior-tui.

**Grade**: A- (proven tool, would need custom integration layer)

---

### kanban-tui (github.com/Zaloog/kanban-tui)

**Stats**: 189 stars | Python | MIT

**Approach**: Terminal Kanban board built with Textual. Multiple boards, customizable columns, task dependencies, analytics. Now includes MCP server and CLI for agent co-op mode.

**Pros**:
- Visual Kanban in terminal (zero tokens to view/manage)
- MCP server for AI agent integration
- CLI interface for scripting
- Web mode via --web flag
- Task dependencies
- Analytics view (bar charts by time period)
- Python (easy to extend)

**Cons**:
- Smaller community (189 stars)
- Python dependency
- Less battle-tested than Taskwarrior
- Limited filtering compared to Taskwarrior

**Grade**: B+ (interesting MCP bridge between human TUI and AI agents)

---

### Taskell (github.com/smallhadroncollider/taskell)

**Stats**: 1,771 stars | Haskell | BSD-3

**Approach**: Command-line Kanban board with Trello and GitHub Projects sync.

**Pros**:
- Clean terminal Kanban view
- Trello and GitHub sync
- Simple and focused

**Cons**:
- Haskell dependency (rare in most environments)
- No AI/agent integration
- Last significant update was years ago
- No MCP or hook system

**Grade**: C+ (nice TUI but stale and no AI integration path)

---

## Category 7: Obsidian-Based Solutions

### Obsidian Kanban Plugin (github.com/mgmeyers/obsidian-kanban)

**Stats**: 3,988 stars | TypeScript | GPL-3.0

**Approach**: Markdown-backed Kanban boards rendered in Obsidian. Cards stored as markdown list items. Integrates with Dataview and obsidian-tasks plugins.

**Pros**:
- Zero token cost (visual Kanban in Obsidian)
- All data in plain markdown (git-friendly, AI-readable)
- Works with Dataview queries for cross-vault task views
- Drag-and-drop visual management
- Tags, dates, metadata on cards
- We already use Obsidian

**Cons**:
- Requires Obsidian open to view (not terminal-native)
- No programmatic API for agents to update tasks
- Markdown format is loosely structured (fragile for parsing)
- No dependency tracking
- No multi-project aggregation

**Potential for our use case**: Medium -- Claude Code could write markdown files in Obsidian format. Human views in Obsidian. But the bridge is fragile and bidirectional sync is hard.

**Grade**: B (great human UX, poor agent integration)

---

### Obsidian Task Board Plugin

**Approach**: Scans vault for tasks in markdown files. Presents them on visual Kanban board. Real-time updates without opening individual notes.

**Pros**:
- Aggregates tasks from across the entire vault
- Visual board with real-time updates
- Zero token cost to view

**Cons**:
- Same limitations as Obsidian Kanban (no agent API)
- Obsidian-dependent
- No dependency management

**Grade**: B- (good aggregation, same integration gaps)

---

### Imdone (imdone.io)

**Stats**: 25 stars (GitHub) | Commercial product

**Approach**: Kanban board that reads TODO/FIXME comments from code files AND markdown. VSCode extension, Obsidian plugin, CLI, Jira sync.

**Pros**:
- Reads tasks from code comments and markdown
- Multi-tool (VSCode, Obsidian, CLI, Jira)
- Local data storage

**Cons**:
- Commercial product (paid)
- Small community
- Code-comment approach can clutter codebase

**Grade**: C+ (interesting approach, commercial barrier)

---

## Emerging Patterns

### Pattern 1: Spec-Driven Development

Tools like CCPM, Spec-Kitty, and ai-dev-tasks structure work as specifications first, then break into tasks. The human writes specs; the AI executes. This naturally creates a human-viewable artifact (the spec) that doesn't require tokens to read.

### Pattern 2: Git as Database

Beads, CCPM, and ROADMAP.md all use git as the persistence layer. This gives version history, branching (per-feature task state), and conflict resolution for free. The trade-off is that querying is harder than a real database.

### Pattern 3: Dual-Interface (CLI for Agents, TUI/Web for Humans)

The most successful tools provide both a CLI/MCP interface for agents AND a visual interface for humans. Beads + beads_viewer, kanban-tui with MCP, and Vibe Kanban all follow this pattern. This directly solves the "don't burn tokens to view" problem.

### Pattern 4: Hydration Pattern

Several workflows (Claude native tasks, planning-with-files) use external files as source of truth and "hydrate" the AI's context at session start. This reduces tokens by only loading what's needed.

### Pattern 5: Worktree Isolation

CCPM, Vibe Kanban, and Spec-Kitty all use git worktrees for parallel agent execution. This prevents conflicts when multiple sessions work simultaneously.

---

## Analysis for Our Use Case

### Requirements Mapping

| Requirement | Must Have | Nice to Have |
|-------------|-----------|-------------|
| View tasks without burning tokens | X | |
| Add/edit tasks without Claude session | X | |
| Programmatic interface for AI agents | X | |
| Multi-domain task organization | X | |
| Session context preservation | X | |
| Parallel session conflict prevention | | X |
| Priority management across domains | X | |
| Dependency tracking | | X |
| Integration with existing YAML system | | X |
| Works in terminal (no web server) | | X |

### Tool Fit Analysis

| Tool | Token-Free View | Agent API | Multi-Domain | Priority | Parallel | Score |
|------|----------------|-----------|-------------|----------|----------|-------|
| Beads + Viewer | Yes (CLI/TUI) | Yes (CLI/MCP) | Tags | CLI sort | Hash IDs | **9/10** |
| CCPM | Yes (GitHub UI) | Yes (issues) | Labels | GitHub | Worktrees | **8/10** |
| Taskwarrior + custom bridge | Yes (CLI/TUI) | Custom hooks | Projects | Built-in | N/A | **7/10** |
| kanban-tui | Yes (TUI) | Yes (MCP) | Boards | Columns | N/A | **7/10** |
| Vibe Kanban | Yes (web/TUI) | Yes (deep) | Projects | Board | Worktrees | **8/10** |
| Obsidian Kanban | Yes (GUI) | No (manual) | Boards | Drag/drop | N/A | **5/10** |
| Claude Task Master | No (MCP only) | Yes (deep) | Tags | AI-managed | N/A | **4/10** |
| planning-with-files | Yes (read MD) | Yes (file I/O) | Files | Manual | N/A | **6/10** |

---

## Recommendations

### Path 1: Beads + beads_viewer (Recommended)

**Why**: Best balance of agent integration and zero-token human visibility.

**How it would work**:
1. Install Beads (`bd init`) in AIProjects
2. Install beads_viewer (`bv`) for Kanban TUI
3. Write a bridge script: `Scripts/sync-orchestration-to-beads.sh` that reads our existing YAML orchestration files and creates/updates Beads issues
4. Add Beads commands to Claude Code CLAUDE.md so agents use `bd` CLI for task management
5. Human views tasks via `bv` (TUI with Kanban, graphs, burndown) -- zero tokens
6. Human adds tasks via `bd create` -- zero tokens
7. Agents update tasks via `bd update` -- minimal tokens (CLI command, not MCP)

**Effort**: 2-3 days (install + bridge script + workflow docs)
**Risk**: Low (MIT license, active development, Steve Yegge backing)
**Token savings**: High (all viewing and most management is token-free)

---

### Path 2: CCPM (GitHub Issues Bridge)

**Why**: Leverages infrastructure we already have (GitHub), provides team-visible tracking with zero token cost.

**How it would work**:
1. Install CCPM in AIProjects
2. Create GitHub Issues for our task domains (labels: infrastructure, coding, research, etc.)
3. Claude Code agents update issues via `gh` CLI
4. Human views/manages via GitHub web UI or `gh issue list` -- zero tokens
5. Parallel execution via git worktrees

**Effort**: 1-2 days (install + label setup + workflow docs)
**Risk**: Low (Shell-based, MIT, well-adopted)
**Token savings**: High (GitHub UI is the dashboard)
**Limitation**: Requires GitHub for everything; GitHub Issues UI is not great for complex project management

---

### Path 3: Hybrid -- kanban-tui + Custom Bridge (Lightest Weight)

**Why**: Minimal tooling, MCP-native, visual TUI for humans, and we already have Python.

**How it would work**:
1. Install kanban-tui (`pip install kanban-tui`)
2. Create boards per domain (infrastructure, coding, research)
3. Enable MCP server mode for Claude Code integration
4. Write bridge script to import from existing YAML orchestration
5. Human views/manages via `kanban-tui` TUI -- zero tokens
6. Agents interact via MCP server -- tokens only when executing tasks

**Effort**: 1 day (install + board setup)
**Risk**: Medium (smaller community, less battle-tested)
**Token savings**: High (TUI is token-free, MCP only during active work)
**Limitation**: Less sophisticated than Beads for dependency management

---

### Not Recommended

- **Claude Task Master**: Despite 25k stars, fails our core requirement (every interaction requires AI session)
- **Vibe Kanban**: Excellent tool but overkill for single-developer use; designed for team orchestration
- **Obsidian Kanban**: Great visual UX but no programmatic API for agent integration
- **Claude Native Tasks**: Zero-token viewing is impossible; designed for AI-first interaction

---

## Quick Comparison of Top 3

| Dimension | Beads + Viewer | CCPM | kanban-tui |
|-----------|---------------|------|-----------|
| Human UX | TUI (Kanban, graphs) | GitHub web UI | TUI (Kanban) |
| Agent Integration | CLI + MCP | GitHub Issues API | MCP server |
| Setup Effort | Medium (2-3 days) | Low (1-2 days) | Low (1 day) |
| Maturity | High (15k stars) | Medium (7k stars) | Lower (189 stars) |
| Dependency Tracking | Built-in (DAG) | GitHub labels | Basic |
| Offline Support | Full | Partial (needs push) | Full |
| Multi-Domain | Tags + labels | Issue labels | Multiple boards |
| Scalability | High (thousands of issues) | Medium (GitHub limits) | Medium |

---

## Sources

### AI-Native Orchestrators
- [Vibe Kanban](https://github.com/BloopAI/vibe-kanban) - 20.6k stars
- [Spec-Kitty](https://github.com/Priivacy-ai/spec-kitty) - 553 stars
- [Ralph TUI](https://github.com/subsy/ralph-tui) - 1.7k stars

### Git-Backed Issue Trackers
- [Beads](https://github.com/steveyegge/beads) - 15.1k stars
- [Beads Viewer](https://github.com/Dicklesworthstone/beads_viewer) - 1.2k stars
- [Tracer](https://github.com/Abil-Shrestha/tracer) - 17 stars
- [Trekker](https://github.com/obsfx/trekker) - 21 stars
- [Issue-Queue](https://github.com/rodmena-limited/issue-queue) - 9 stars

### GitHub Issues Bridges
- [CCPM](https://github.com/automazeio/ccpm) - 7k stars

### MCP Task Servers
- [Claude Task Master](https://github.com/eyaltoledano/claude-task-master) - 25.3k stars

### File-Based Approaches
- [Planning-with-Files](https://github.com/OthmanAdi/planning-with-files) - 13.1k stars
- [ai-dev-tasks](https://github.com/snarktank/ai-dev-tasks) - 7.4k stars
- [Agentic Project Management](https://github.com/sdi2200262/agentic-project-management) - 2k stars
- [Claude Roadmap Commands](https://github.com/arach/claude-roadmap-commands)

### Traditional CLI/TUI Tools
- [Taskwarrior](https://github.com/GothenburgBitFactory/taskwarrior) - 5.5k stars
- [kanban-tui](https://github.com/Zaloog/kanban-tui) - 189 stars
- [Taskell](https://github.com/smallhadroncollider/taskell) - 1.8k stars

### Obsidian-Based
- [Obsidian Kanban](https://github.com/mgmeyers/obsidian-kanban) - 4k stars
- [Imdone](https://imdone.io/)

### Articles and References
- [Claude Code Task Management Guide](https://claudefa.st/blog/guide/development/task-management)
- [Claude Code Tasks (VentureBeat)](https://venturebeat.com/orchestration/claude-codes-tasks-update-lets-agents-work-longer-and-coordinate-across)
- [Claude Code as Project Manager (Ben Newton)](https://benenewton.com/blog/claude-code-roadmap-management)
- [Minimalist Task Management Workflow (Nick Tune)](https://medium.com/nick-tune-tech-strategy-blog/minimalist-claude-code-task-management-workflow-7b7bdcbc4cc1)
- [Introducing Beads (Steve Yegge)](https://steve-yegge.medium.com/introducing-beads-a-coding-agent-memory-system-637d7d92514a)
- [CCPM Context Problem (Ran Aroussi)](https://aroussi.com/post/ccpm-claude-code-project-management)
- [Bridging Human Intent and AI Execution (typevar.dev)](https://typevar.dev/articles/BloopAI/vibe-kanban)
- [Vibe Kanban Review (Eleanor Berger)](https://elite-ai-assisted-coding.dev/p/vibe-kanban-tool-review)
- [Spec-Driven Development (Martin Fowler)](https://martinfowler.com/articles/exploring-gen-ai/sdd-3-tools.html)
