---
type: claude-knowledge
source: aiprojects
source_path: ".claude/agent-output/results/deep-research/2026-02-10_template-repo-stay-current-patterns.md"
source_category: "deep-research"
synced: 2026-02-17
title: "Deep Research: Template Repo "Stay Current" Patterns for AIfred"
tags:
  - claude-knowledge
  - deep-research
---

# Deep Research: Template Repo "Stay Current" Patterns for AIfred

**Research Date**: 2026-02-10
**Confidence Level**: High
**Sources Consulted**: 18+

## Executive Summary

The "stay current" problem for template repos is well-understood across multiple ecosystems but has no single dominant solution. The Claude Code plugin ecosystem itself provides a marketplace-based update mechanism (pin-to-commit-SHA, explicit `plugin update` command) but this only applies to official plugins, not to template repos that users clone and customize. The broader ecosystem offers three major approaches: (1) template sync tools like Cruft/Copier that use 3-way merge with answers files, (2) GitHub Actions like actions-template-sync with ignore files, and (3) component-based selective update systems. For AIfred specifically, a hybrid approach combining a manifest file (`.aifred.yaml`) with component-level granularity and a CLI-driven update command is recommended.

## Key Findings

### 1. Claude Code Plugin Ecosystem

#### Official Plugin Update Mechanism

The Claude Code plugin system (v1.0.33+) uses a **marketplace-based distribution model** with the following characteristics:

- **Pin-to-SHA**: When a plugin is installed, Claude Code records the exact git commit SHA. It never checks for updates automatically (until v2.0.70 added opt-in auto-updates).
- **Explicit update command**: `claude plugin update <plugin-name>@<marketplace>` fetches the latest version.
- **Version tracking**: Plugins use semantic versioning in `plugin.json` manifests.
- **Plugin caching**: Plugins are copied to `~/.claude/plugins/` cache directory, not used in-place.
- **Installed state**: Tracked in `~/.claude/plugins/installed_plugins_v2.json`.
- **Scope-based installation**: user, project, local, or managed scopes.
- **No selective component updates**: A plugin is updated atomically -- you get all changes or none.

**Key limitation**: This system is for *distributing discrete plugins*, not for template repos that users customize. There is no mechanism for "merge upstream changes while preserving my customizations."

Source: [Claude Code Plugin Docs](https://code.claude.com/docs/en/plugins), [Plugin Reference](https://code.claude.com/docs/en/plugins-reference), [Plugin Marketplaces](https://code.claude.com/docs/en/plugin-marketplaces)

#### Community Plugin Management

The community has identified the update gap. A [blog post by Working Bruno](https://workingbruno.com/notes/keeping-claude-code-plugins-date) documents the challenge: plugins are pinned to SHAs and users must manually trigger updates. A community bash script was developed to compare installed SHAs against marketplace HEAD to detect available updates.

As of Claude Code v2.0.70, native auto-update functionality was added for plugin marketplaces, but this is per-marketplace opt-in and only applies to the plugin system, not template repos.

Source: [Working Bruno - Keeping Claude Code Plugins Up to Date](https://workingbruno.com/notes/keeping-claude-code-plugins-date)

### 2. Community Claude Code Extension Repos

An analysis of 50+ community Claude Code repos from the [Awesome Claude Code](https://github.com/hesreallyhim/awesome-claude-code) collection reveals:

**No template repos implement a "stay current" mechanism.** The community repos fall into several categories:

| Category | Examples | Update Pattern |
|----------|----------|----------------|
| **Skill collections** | claude-skills, cc-devops-skills, trail-of-bits/skills | Users copy files manually; no update tracking |
| **Config templates** | claude-starter-kit, my-claude-code-setup, claude-code-templates | Clone once, diverge forever; no upstream sync |
| **Workflow frameworks** | SuperClaude, Claude-CodePro, RIPER | Fork/clone, customize; manual diff to update |
| **CLI tools** | ccexp, claudekit, cc-tools | Standard package managers (npm, cargo) handle updates |
| **Orchestrators** | claude-squad, claude-swarm, claude-flow | Installed as tools, not templates |

**Notable finding**: [Rulesync](https://github.com/dyoshikawa/rulesync) converts configs between Claude Code and other AI agents but does not solve the template-to-fork sync problem.

**Gap**: No community Claude Code repo has implemented selective template sync with preference tracking. This is an open opportunity for AIfred.

### 3. Template Repo Update Patterns (Broader Ecosystem)

#### 3.1 Cruft (Python/Cookiecutter ecosystem)

**How it works**: Cruft wraps Cookiecutter, adding a `.cruft.json` tracking file that records the template commit hash and user-provided answers. `cruft update` computes a diff between the original template version and the latest, then applies those changes to the user's project.

**Key features**:
- `.cruft.json` stores template commit hash + user answers (the "preferences" file)
- `cruft diff` shows what would change without applying
- `cruft update` applies changes with interactive review
- **Skip list**: Users add files to a `skip` array in `.cruft.json` using glob patterns to permanently exclude files from updates
- **Rejection via PR**: In CI workflows, cruft creates two PRs -- one with actual changes, one that only bumps `.cruft.json` (effectively "rejecting" the update while marking as current)
- `cruft check` validates if project is up-to-date (useful for CI)

**Limitations**: Designed for Cookiecutter Jinja templates, not arbitrary git repos. The 3-way merge can be confusing when user changes overlap with template changes.

Source: [Cruft Documentation](https://cruft.github.io/cruft/), [Cruft GitHub](https://github.com/cruft/cruft), [Cookiecutter + Cruft for Platform Engineering](https://john-miller.dev/posts/cookiecutter-with-cruft-for-platform-engineering/)

#### 3.2 Copier (Python ecosystem)

**How it works**: Similar to Cruft but with more sophisticated conflict resolution. Uses `.copier-answers.yml` to track user choices. Supports Jinja2 templating with conditional file inclusion.

**Key features**:
- `.copier-answers.yml` persists all user choices (never edit manually)
- `copier update` uses 3-way merge between (original template, current template, user's project)
- `--conflict rej` creates `.rej` files for unresolvable conflicts (like git merge conflicts)
- `--conflict inline` uses inline conflict markers
- `--skip-answered` only asks about new template questions
- Conditional file inclusion via Jinja: `{% if include_ci %}.gitlab-ci.yml{% endif %}`
- `_exclude` patterns for files that should never be templated
- `_skip_if_exists` for files that should only be created on initial generation

**Strengths**: Best-in-class conflict handling. The conditional file inclusion pattern (template questions that control which files get generated) is directly relevant to AIfred's component model.

Source: [Copier - Updating a Project](https://copier.readthedocs.io/en/stable/updating/), [Copier - Configuring a Template](https://copier.readthedocs.io/en/stable/configuring/)

#### 3.3 Create React App Pattern

**How it works**: CRA chose a fundamentally different approach -- hide all config behind `react-scripts` and provide an irreversible `eject` command that exposes everything. Updates are via `npm update react-scripts`.

**Key insight**: The "eject" pattern is instructive as an *anti-pattern* for AIfred. Once ejected, you lose all ability to update. The community response (react-app-rewired, CRACO) shows that users want to customize without forking -- they want an *overlay* pattern.

**Relevance to AIfred**: The overlay pattern (keep a base layer untouched, apply customizations on top) is the most user-friendly approach.

Source: [react-app-rewired](https://github.com/timarney/react-app-rewired)

#### 3.4 GitHub Actions Template Sync

**How it works**: GitHub Actions like [actions-template-sync](https://github.com/AndreasAugustin/actions-template-sync) periodically check a source template repo and create PRs with changes.

**Key features**:
- `.templatesyncignore` file (glob patterns, like `.gitignore`) defines files to exclude from sync
- Can be stored in `.github/` directory
- The ignore file itself cannot be synced (protected)
- Creates PRs rather than direct commits, allowing human review
- Runs on schedule (e.g., weekly) or on push

**Limitation**: Requires GitHub Actions (CI infrastructure). Not suitable for local-only workflows.

Source: [actions-template-sync](https://github.com/AndreasAugustin/actions-template-sync), [GitHub template-sync topic](https://github.com/topics/template-sync)

#### 3.5 Chezmoi Pattern (Dotfiles)

**How it works**: Chezmoi manages dotfiles by generating final files from templates, supporting ignore patterns via `.chezmoiignore`, templates via Go text/template, and machine-specific conditional logic.

**Relevance**: The `.chezmoiignore` pattern (declare what you DON'T want) combined with template variables for conditional inclusion is a strong model for AIfred.

Source: [chezmoi](https://www.chezmoi.io/)

### 4. Git-Based Update Strategies

| Strategy | Mechanism | Selective? | Preference Tracking | Complexity |
|----------|-----------|-----------|---------------------|------------|
| **Upstream remote + merge** | `git remote add upstream; git merge upstream/main` | No (all-or-nothing) | None | Low |
| **Upstream remote + cherry-pick** | Manual cherry-pick of specific commits | Yes (per-commit) | None (manual) | High |
| **Template sync tools** | `.templatesyncignore` + PR creation | Yes (file-level) | Ignore file | Medium |
| **Cruft/Copier** | 3-way merge + answers file | Yes (file + question level) | `.cruft.json` / `.copier-answers.yml` | Medium |
| **Patch-based** | Generate and apply patches per component | Yes (component-level) | Custom manifest | Medium-High |
| **Component registry** | Each component versioned independently | Yes (component-level) | Config file | High initial, Low ongoing |

### 5. Preference/Exclusion Tracking Patterns

| System | Mechanism | What It Tracks |
|--------|-----------|----------------|
| **Cruft** | `.cruft.json` skip array | Files to never update (glob patterns) |
| **Copier** | `.copier-answers.yml` | User answers to template questions (controls conditional files) |
| **actions-template-sync** | `.templatesyncignore` | Files to exclude from sync (gitignore-style) |
| **Chezmoi** | `.chezmoiignore` | Files to not manage |
| **npm** | `package.json` optionalDependencies | Packages that can fail without breaking install |
| **Feature flags** | Config file (YAML/JSON) | Per-feature boolean with metadata (creation date, owner, expiry) |
| **Claude Code plugins** | `enabledPlugins` in settings.json | Plugin-name@marketplace -> boolean toggle |

## Detailed Analysis

### The Core Tension

Template repos face a fundamental tension: **the more users customize, the harder updates become**. There are three strategies for managing this:

1. **Minimize customization surface**: Like CRA's `react-scripts` -- hide config behind an abstraction. Users can update easily but have limited customization. Anti-pattern for AIfred since the whole point is customization.

2. **Track customization intent**: Like Copier/Cruft -- record what the user chose and why, so the tool can intelligently merge. Good for initial setup, but AIfred's customizations are ongoing and organic.

3. **Component isolation**: Like npm packages -- each piece is independently versioned and updateable. Users choose which components to include. Most flexible but requires the most upfront architecture.

### AIfred's Unique Constraints

AIfred is a Claude Code template repo with these specific characteristics:
- Components are `.claude/` directory contents: commands, skills, hooks, agents
- Users will add their own components alongside template ones
- Users may modify template components (customize a hook, tweak a command)
- Components have light dependencies (a hook might reference a command)
- The "distribution unit" is a directory structure, not a package

This most closely matches the **Copier + component registry hybrid**.

## Best Practices

1. **Never force-update user-modified files**: Any file the user has touched should require explicit confirmation before updating.

2. **Track what came from upstream vs. what's local**: A manifest file should clearly distinguish "came from AIfred template" vs. "user-created."

3. **Support "reject and remember"**: When a user declines an update to a component, record that decision so they aren't asked again until a new version is available.

4. **Make updates reviewable**: Show diffs before applying. PR-style review is ideal.

5. **Version components independently**: Not all components change at the same rate. A hook bugfix shouldn't require reviewing every skill.

6. **Provide a check command**: Let users see if they're behind without applying anything (like `cruft check`).

## Common Pitfalls

1. **All-or-nothing updates**: Upstream merge/rebase strategies force users to accept everything or nothing. Always provide component-level granularity.

2. **Silent overwrites**: Never overwrite user changes without confirmation. This destroys trust and causes data loss.

3. **Manual diffing**: Forcing users to manually diff upstream changes against their repo is error-prone and exhausting. Automate the comparison.

4. **No memory of rejections**: If users decline an update and the tool asks again next time, it becomes annoying. Track rejections.

5. **Tight coupling**: If updating component A requires also updating B, C, and D, the system feels fragile. Design for independent components.

## Conflicting Information

- **Cruft vs. Copier**: Both solve the same problem with slightly different approaches. Cruft uses `.cruft.json` with skip lists; Copier uses `.copier-answers.yml` with conditional templates. Copier's 3-way merge is considered more robust but more complex. Neither is clearly "better" -- choice depends on whether you want the template to define conditions (Copier) or the user to define exclusions (Cruft).

- **Atomic vs. granular updates**: Claude Code's plugin system uses atomic updates (whole plugin at once). The broader template ecosystem strongly favors granular/selective updates. For AIfred, granular is clearly better since users will customize individual components.

## Knowledge Gaps

1. **No precedent in Claude Code ecosystem**: No Claude Code template repo has implemented a "stay current" mechanism. AIfred would be first.

2. **Component dependency resolution**: If hook A depends on command B, and the user updates B but not A, what happens? No existing system handles this well for Claude Code's structure.

3. **AI-assisted merge**: No tool currently uses AI to resolve merge conflicts in template updates. This could be a differentiator -- Claude Code itself could review and apply updates intelligently.

## Recommendations

### Recommended High-Level Pattern for AIfred's "Stay Current" Command

**Pattern: Component Registry with Manifest Tracking**

This hybrid combines the best elements from Copier's answers file, Cruft's skip list, actions-template-sync's ignore patterns, and Claude Code's plugin system.

#### Core Design

```
.aifred.yaml              # The manifest (like .cruft.json + .copier-answers.yml)
.aifred-ignore             # User-defined exclusions (like .templatesyncignore)
```

#### `.aifred.yaml` Structure

```yaml
# Automatically maintained -- do not edit manually
aifred_version: "2.1.0"        # Version of AIfred template this was generated from
aifred_repo: "https://github.com/user/aifred"
installed_at: "2026-02-01T10:00:00Z"
last_checked: "2026-02-10T14:00:00Z"
last_updated: "2026-02-08T09:00:00Z"

# Component tracking
components:
  hooks/session-start.js:
    source_version: "2.1.0"     # AIfred version this came from
    source_sha: "abc123"        # Hash of the original file
    local_sha: "abc123"         # Hash of the current local file
    status: "current"           # current | modified | outdated | rejected
  hooks/audit-logger.js:
    source_version: "2.0.0"
    source_sha: "def456"
    local_sha: "xyz789"         # Different = user modified
    status: "modified"
  skills/deployment/SKILL.md:
    source_version: "2.0.0"
    source_sha: "ghi012"
    local_sha: "ghi012"
    status: "rejected"          # User explicitly rejected v2.1.0 update
    rejected_version: "2.1.0"
    rejected_at: "2026-02-05"

# User-created components (not tracked for upstream updates)
user_components:
  - hooks/my-custom-hook.js
  - skills/my-workflow/SKILL.md
  - commands/my-command.md

# Profile choices (like Copier answers)
profile:
  include_docker_hooks: true
  include_session_management: true
  include_infrastructure_ops: false   # User opted out of this module
  include_fabric: false
```

#### `.aifred-ignore` Structure

```gitignore
# Files to never update from upstream (gitignore syntax)
# These are always skipped, even if upstream has changes
CLAUDE.md          # User has heavily customized this
hooks/custom-*.js  # All custom hooks
paths-registry.yaml
```

#### Command Interface

```bash
# Check for updates (no changes applied)
aifred check
# Output:
#   AIfred v2.1.0 -> v2.3.0 available
#   3 components have updates:
#     hooks/session-start.js: v2.1.0 -> v2.3.0 (new feature)
#     skills/planning/SKILL.md: v2.1.0 -> v2.2.0 (bugfix)
#     hooks/audit-logger.js: v2.1.0 -> v2.3.0 (CONFLICT: you modified this)
#   1 component rejected (use --show-rejected to see)
#   2 new components available:
#     skills/code-review/SKILL.md (new in v2.2.0)
#     hooks/lsp-integration.js (new in v2.3.0)

# Interactive update
aifred update
# For each component:
#   [Y] Accept update
#   [n] Skip this time (will ask again next update)
#   [r] Reject permanently (won't ask until NEXT new version)
#   [d] Show diff
#   [m] Merge (for modified files -- show 3-way diff)

# Update specific component
aifred update hooks/session-start.js

# Show what you've rejected
aifred check --show-rejected

# Re-enable a rejected component
aifred unreject skills/deployment/SKILL.md

# Show status of all components
aifred status
```

#### Implementation Approach

**Phase 1 (MVP)**: Simple version tracking
- `.aifred.yaml` with component list and SHA hashes
- `aifred check` compares local SHAs against upstream
- `aifred update` does file-level replace with confirmation
- `.aifred-ignore` for permanent exclusions

**Phase 2**: Smart merge
- Detect user modifications (local_sha != source_sha)
- Show 3-way diffs for modified files
- Track rejection decisions with version context
- Profile-based conditional components

**Phase 3**: AI-assisted updates
- Use Claude Code itself to review and apply updates
- Understand semantic changes (not just text diffs)
- Suggest how to reconcile user modifications with upstream changes
- `/aifred:update` slash command that runs within Claude Code

### Why This Pattern

| Requirement | How It's Met |
|-------------|-------------|
| Pull new releases | `aifred check` + `aifred update` fetch from upstream repo |
| Preserve customizations | SHA comparison detects user-modified files; never overwrites silently |
| Track opt-outs | `rejected` status in `.aifred.yaml` + `.aifred-ignore` for permanent exclusions |
| Component-level granularity | Each file tracked independently in the manifest |
| Version awareness | Template version + per-component version tracking |
| Low friction | Check command is read-only; update is interactive with sensible defaults |
| Familiar patterns | Combines `.gitignore` (exclusions) + `.cruft.json` (tracking) + `npm update` (selective) |

## Related Topics

- Claude Code plugin marketplace architecture and how AIfred could optionally distribute as a plugin marketplace alongside the template repo
- Copier's Jinja-based conditional file generation for profile-based AIfred setups
- Git submodules as an alternative to component tracking (trade-offs: atomic version but poor UX)
- Nix flakes as inspiration for reproducible component pinning

## Sources

1. [Claude Code - Create Plugins](https://code.claude.com/docs/en/plugins) - Official plugin system docs (High credibility)
2. [Claude Code - Plugins Reference](https://code.claude.com/docs/en/plugins-reference) - Full manifest schema, versioning, caching (High credibility)
3. [Claude Code - Plugin Marketplaces](https://code.claude.com/docs/en/plugin-marketplaces) - Distribution and update mechanism (High credibility)
4. [Working Bruno - Keeping Claude Code Plugins Up to Date](https://workingbruno.com/notes/keeping-claude-code-plugins-date) - Community analysis of plugin update gaps (Medium-High credibility)
5. [Awesome Claude Code](https://github.com/hesreallyhim/awesome-claude-code) - Curated list of 50+ Claude Code repos (Medium credibility)
6. [Cruft Documentation](https://cruft.github.io/cruft/) - Template sync tool for Cookiecutter (High credibility)
7. [Cruft GitHub](https://github.com/cruft/cruft) - Skip files, rejection mechanism (High credibility)
8. [Cookiecutter + Cruft for Platform Engineering](https://john-miller.dev/posts/cookiecutter-with-cruft-for-platform-engineering/) - Real-world usage patterns (Medium credibility)
9. [Copier - Updating a Project](https://copier.readthedocs.io/en/stable/updating/) - 3-way merge, conflict resolution (High credibility)
10. [Copier - Configuring a Template](https://copier.readthedocs.io/en/stable/configuring/) - Conditional files, exclude patterns (High credibility)
11. [actions-template-sync](https://github.com/AndreasAugustin/actions-template-sync) - GitHub Actions template sync (High credibility)
12. [template-tools/template-sync](https://github.com/template-tools/template-sync) - NPM-based template sync (Medium credibility)
13. [ahmadnassri/action-template-repository-sync](https://github.com/ahmadnassri/action-template-repository-sync) - Auto-detect and sync downstream repos (Medium credibility)
14. [GitHub Community Discussion #23528](https://github.com/orgs/community/discussions/23528) - How to sync template changes (Medium credibility)
15. [react-app-rewired](https://github.com/timarney/react-app-rewired) - Override pattern without ejecting (High credibility)
16. [chezmoi](https://www.chezmoi.io/) - Dotfiles management with ignore patterns (High credibility)
17. [Martin Fowler - Feature Toggles](https://martinfowler.com/articles/feature-toggles.html) - Feature flag patterns (High credibility)
18. [GitHub Templates and Repository Sync](https://0xdc.me/blog/github-templates-and-repository-sync/) - Overview of the problem space (Medium credibility)
