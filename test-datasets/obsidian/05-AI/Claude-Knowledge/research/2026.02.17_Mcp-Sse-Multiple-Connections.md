---
type: claude-knowledge
source: aiprojects
source_path: ".claude/agent-output/results/deep-research/2026-02-17_mcp-sse-multiple-connections.md"
source_category: "deep-research"
synced: 2026-02-17
title: "Deep Research: MCP SSE Multiple Connections and Transport Evolution"
tags:
  - claude-knowledge
  - deep-research
---

# Deep Research: MCP SSE Multiple Connections and Transport Evolution

**Research Date**: 2026-02-17
**Confidence Level**: High
**Sources Consulted**: 12+

## Executive Summary

`SSEServerTransport` is deprecated and has been **completely removed** from the latest SDK (`main` branch / v2.x). The replacement is `NodeStreamableHTTPServerTransport` from `@modelcontextprotocol/node` (or `WebStandardStreamableHTTPServerTransport` from `@modelcontextprotocol/server` for non-Node runtimes). The core design principle is: **one McpServer instance per connection** for the factory pattern, or **one McpServer shared with per-session transports** tracked via a Map. The error "Already connected to a transport" occurs because `Protocol.connect()` replaces the transport, and calling it twice on the same server/transport pair without closing first is invalid.

## Key Findings

### 1. SSEServerTransport Is Removed (Not Just Deprecated)

The SDK has been restructured into a monorepo with separate packages:
- `@modelcontextprotocol/core` -- shared types and protocol
- `@modelcontextprotocol/client` -- client transports (SSEClientTransport still exists for backwards compat)
- `@modelcontextprotocol/server` -- McpServer, StdioServerTransport, WebStandardStreamableHTTPServerTransport
- `@modelcontextprotocol/node` -- NodeStreamableHTTPServerTransport
- `@modelcontextprotocol/express` -- Express middleware helpers

The v1-to-v2 migration guide explicitly states:
> `@modelcontextprotocol/sdk/server/sse.js` --> **REMOVED (migrate to Streamable HTTP)**

Source: [migration-SKILL.md in the SDK repo](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/docs/migration-SKILL.md)

If you are on v1.x (`@modelcontextprotocol/sdk`), `SSEServerTransport` still exists but is deprecated. If you upgrade to v2.x (the split packages), it is gone entirely.

### 2. The Correct Multi-Client Pattern (Streamable HTTP)

There are **two sanctioned patterns** in the official examples:

#### Pattern A: Stateful -- One McpServer Factory, Per-Session Transports (Recommended)

From `simpleStreamableHttp.ts` -- the primary reference example:

```typescript
import { randomUUID } from 'node:crypto';
import { createMcpExpressApp } from '@modelcontextprotocol/express';
import { NodeStreamableHTTPServerTransport } from '@modelcontextprotocol/node';
import { isInitializeRequest, McpServer } from '@modelcontextprotocol/server';
import type { Request, Response } from 'express';

// Factory function that creates a NEW McpServer per connection
const getServer = () => {
    const server = new McpServer({
        name: 'my-server',
        version: '1.0.0'
    });
    server.registerTool('greet', { /* ... */ }, async ({ name }) => { /* ... */ });
    return server;
};

const app = createMcpExpressApp();

// Map to store transports by session ID
const transports: { [sessionId: string]: NodeStreamableHTTPServerTransport } = {};

app.post('/mcp', async (req: Request, res: Response) => {
    const sessionId = req.headers['mcp-session-id'] as string | undefined;

    let transport: NodeStreamableHTTPServerTransport;

    if (sessionId && transports[sessionId]) {
        // Reuse existing transport for this session
        transport = transports[sessionId];
    } else if (!sessionId && isInitializeRequest(req.body)) {
        // New client connecting -- create new transport AND new server
        transport = new NodeStreamableHTTPServerTransport({
            sessionIdGenerator: () => randomUUID(),
            onsessioninitialized: (id) => {
                transports[id] = transport;
            }
        });

        transport.onclose = () => {
            const sid = transport.sessionId;
            if (sid && transports[sid]) {
                delete transports[sid];
            }
        };

        // CRITICAL: New server instance per connection
        const server = getServer();
        await server.connect(transport);

        await transport.handleRequest(req, res, req.body);
        return;
    } else {
        res.status(400).json({ /* error */ });
        return;
    }

    await transport.handleRequest(req, res, req.body);
});

// GET for SSE stream (server-to-client notifications)
app.get('/mcp', async (req: Request, res: Response) => {
    const sessionId = req.headers['mcp-session-id'] as string | undefined;
    if (!sessionId || !transports[sessionId]) {
        res.status(400).send('Invalid or missing session ID');
        return;
    }
    const transport = transports[sessionId];
    await transport.handleRequest(req, res);
});

// DELETE for session termination
app.delete('/mcp', async (req: Request, res: Response) => {
    const sessionId = req.headers['mcp-session-id'] as string | undefined;
    if (!sessionId || !transports[sessionId]) {
        res.status(400).send('Invalid or missing session ID');
        return;
    }
    const transport = transports[sessionId];
    await transport.handleRequest(req, res);
});
```

Key points:
- `getServer()` factory creates a fresh `McpServer` per initialization request
- Each session gets its own transport stored in a `transports` map keyed by session ID
- Session ID comes from the `Mcp-Session-Id` header
- The `onsessioninitialized` callback stores the transport (avoids race conditions)
- `transport.onclose` cleans up the map entry

#### Pattern B: Stateless -- New Server + Transport Per Request

From `simpleStatelessStreamableHttp.ts`:

```typescript
app.post('/mcp', async (req: Request, res: Response) => {
    // Brand new server AND transport for EVERY request
    const server = getServer();
    const transport = new NodeStreamableHTTPServerTransport({
        sessionIdGenerator: undefined  // No sessions
    });
    await server.connect(transport);
    await transport.handleRequest(req, res, req.body);

    res.on('close', () => {
        transport.close();
        server.close();
    });
});
```

This is simpler but has no session continuity. Each request is fully isolated.

#### Pattern C: Shared McpServer with Per-Session Transports (Notification Use Case)

From `standaloneSseWithGetStreamableHttp.ts` -- used when the server needs to push notifications to all sessions (e.g., resource changes):

```typescript
// ONE shared McpServer
const server = new McpServer({ name: 'notification-server', version: '1.0.0' });
const transports: { [sessionId: string]: NodeStreamableHTTPServerTransport } = {};

app.post('/mcp', async (req: Request, res: Response) => {
    const sessionId = req.headers['mcp-session-id'] as string | undefined;
    let transport: NodeStreamableHTTPServerTransport;

    if (sessionId && transports[sessionId]) {
        transport = transports[sessionId];
    } else if (!sessionId && isInitializeRequest(req.body)) {
        transport = new NodeStreamableHTTPServerTransport({
            sessionIdGenerator: () => randomUUID(),
            onsessioninitialized: (id) => {
                transports[id] = transport;
            }
        });
        // Connect SHARED server to this transport
        await server.connect(transport);
        await transport.handleRequest(req, res, req.body);
        return;
    }

    await transport.handleRequest(req, res, req.body);
});
```

**NOTE**: This pattern works because in the v2 SDK, `McpServer.connect()` delegates to `Server.connect()` which sets `this._transport = transport`. The v2 `Server` class appears to support multiple transports (the connect method no longer throws "Already connected" -- it just replaces). However, this pattern is primarily shown for the notification use case, not general multi-tool servers.

### 3. The "Already Connected" Error

This error (`SdkErrorCode.AlreadyConnected`) in v2 is thrown from `registerCapabilities()` if you try to register capabilities after connecting, NOT from `connect()` itself. In v1, the `Protocol.connect()` method would throw if already connected.

The fix is the same regardless of version: **create a new McpServer instance per connection**.

The v2 SDK renamed the error to `SdkError` with `SdkErrorCode.AlreadyConnected`.

### 4. Official Examples Summary

The SDK repo at `examples/server/src/` contains these relevant files:

| File | Pattern | Multi-Client? |
|------|---------|---------------|
| `simpleStreamableHttp.ts` | Stateful, factory `getServer()` | YES -- new McpServer per session |
| `simpleStatelessStreamableHttp.ts` | Stateless, new everything per request | YES -- complete isolation |
| `standaloneSseWithGetStreamableHttp.ts` | Shared server, per-session transports | YES -- shared state, notifications |
| `ssePollingExample.ts` | Stateful with event store + retry | YES -- resumable connections |
| `jsonResponseStreamableHttp.ts` | JSON-only (no SSE streaming) | YES |
| `honoWebStandardStreamableHttp.ts` | Hono framework variant | YES |

### 5. The Deprecation Timeline

| Date | Event |
|------|-------|
| 2024-11-05 | MCP protocol version with HTTP+SSE transport |
| 2025-03-26 | MCP spec update introduces Streamable HTTP, deprecates SSE |
| 2025-04-17 | TypeScript SDK v1.10.0 adds `StreamableHTTPServerTransport` |
| 2025-Q4+ | SDK restructured into monorepo (v2.x) |
| 2026-02-16 | SDK v1.27.0 (latest v1.x release) |
| Current | `main` branch is v2.x -- `SSEServerTransport` fully removed |

## Best Practices

1. **Use Streamable HTTP for all new servers.** SSE server transport is gone in v2.
2. **Use Pattern A (factory)** for most servers -- it provides clean isolation per client.
3. **Use Pattern B (stateless)** for serverless/lambda deployments where you cannot maintain state.
4. **Use Pattern C (shared server)** only when you need to broadcast notifications to all connected clients.
5. **Always handle DELETE /mcp** for clean session termination.
6. **Use `onsessioninitialized`** callback (not inline assignment) to store transports -- avoids race conditions.
7. **Clean up on close** -- set `transport.onclose` to remove from the transports map.
8. **Use `createMcpExpressApp()`** from `@modelcontextprotocol/express` -- it sets up security defaults (Host header validation, etc.).

## Common Pitfalls

1. **Calling `server.connect(transport)` twice on the same McpServer without closing** -- will overwrite the previous transport silently in v2, or throw in v1.
2. **Not tracking sessions** -- if you create a new transport per POST but don't store it by session ID, the client's second request won't find its transport.
3. **Missing the GET handler** -- Streamable HTTP uses GET for server-initiated SSE streams. Without it, server notifications won't work.
4. **Using `@modelcontextprotocol/sdk` (v1) in new projects** -- it's the old monolithic package. Use the split packages.
5. **Trying to reuse SSEServerTransport patterns** -- the dual-endpoint model (`/sse` + `/messages`) is replaced by a single `/mcp` endpoint with GET/POST/DELETE.
6. **Forgetting `sessionIdGenerator`** -- without it (or set to `undefined`), the server runs in stateless mode with no session tracking.

## Conflicting Information

- The `standaloneSseWithGetStreamableHttp.ts` example uses a SINGLE shared `McpServer` and calls `server.connect(transport)` for each new session. This appears to work but contradicts the GitHub issue #204 consensus that "each connection requires its own McpServer instance." The resolution: the v2 SDK's `connect()` method replaces the transport rather than throwing, but this means only the LAST connected transport receives responses from the shared server. This pattern works for the notification use case shown (broadcasting resource changes) but would fail for independent tool calls from different clients.

- The `ssePollingExample.ts` also uses a single shared `McpServer` with `await server.connect(transport)` per session. This suggests the SDK team considers this pattern valid for certain use cases, but the `simpleStreamableHttp.ts` (the "primary" example) uses the factory pattern, which is safer.

## Knowledge Gaps

- The exact behavior of `Server.connect()` in v2 when called multiple times (does it multiplex or replace?) is not documented. The source code shows it replaces `this._transport`, suggesting only the last-connected transport is active.
- Whether the v2 SDK will add first-class multi-transport support is unclear.
- The `@modelcontextprotocol/sdk` v1.x package still publishes `SSEServerTransport` but it's unclear how long v1.x will receive maintenance updates.

## Recommendations

For your homelab MCP server:

1. **If you're on v1.x (`@modelcontextprotocol/sdk`)**: Use the factory pattern -- create a new `McpServer` per SSE connection. This is the confirmed working approach from GitHub issue #204.

2. **If starting fresh or upgrading**: Use v2 split packages with `NodeStreamableHTTPServerTransport` and the Pattern A factory approach from `simpleStreamableHttp.ts`.

3. **For n8n compatibility**: n8n's MCP trigger node expects SSE. Check if n8n has updated to support Streamable HTTP. If not, you may need to run a backwards-compatible server that supports both (the SDK's `sseAndStreamableHttpCompatibleServer.ts` example, though this wasn't found in the current `main` branch examples).

## Sources

1. [GitHub Issue #204: Multiple clients to the same SSE connection?](https://github.com/modelcontextprotocol/typescript-sdk/issues/204) -- **Credibility: HIGH** (official repo, maintainer responses)
2. [SDK server documentation (docs/server.md)](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/docs/server.md) -- **Credibility: HIGH**
3. [SDK migration guide (docs/migration-SKILL.md)](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/docs/migration-SKILL.md) -- **Credibility: HIGH** (confirms SSEServerTransport removed in v2)
4. [simpleStreamableHttp.ts example](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/examples/server/src/simpleStreamableHttp.ts) -- **Credibility: HIGH** (official example)
5. [simpleStatelessStreamableHttp.ts example](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/examples/server/src/simpleStatelessStreamableHttp.ts) -- **Credibility: HIGH**
6. [standaloneSseWithGetStreamableHttp.ts example](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/examples/server/src/standaloneSseWithGetStreamableHttp.ts) -- **Credibility: HIGH**
7. [ssePollingExample.ts example](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/examples/server/src/ssePollingExample.ts) -- **Credibility: HIGH**
8. [Why MCP Deprecated SSE (blog post)](https://blog.fka.dev/blog/2025-06-06-why-mcp-deprecated-sse-and-go-with-streamable-http/) -- **Credibility: MEDIUM** (third-party, well-researched)
9. [MCP Specification: Transports](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports) -- **Credibility: HIGH** (official spec)
10. [GitHub Issue #1215: Support for multiple clients in McpServer](https://github.com/modelcontextprotocol/servers/issues/1215) -- **Credibility: HIGH**
11. [SDK releases page](https://github.com/modelcontextprotocol/typescript-sdk/releases) -- **Credibility: HIGH**
12. [NPM: @modelcontextprotocol/sdk](https://www.npmjs.com/package/@modelcontextprotocol/sdk) -- **Credibility: HIGH**

## Related Topics

- Streamable HTTP resumability (event stores, Last-Event-ID)
- MCP OAuth 2.0 integration with Streamable HTTP
- n8n MCP trigger node compatibility with Streamable HTTP
- Cloudflare Workers MCP deployment (WebStandardStreamableHTTPServerTransport)
