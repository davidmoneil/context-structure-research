---
type: claude-knowledge
source: aiprojects
source_path: ".claude/agent-output/results/deep-research/2026-02-18_codebase-indexing-for-ai-assistants.md"
source_category: "deep-research"
synced: 2026-02-18
title: "Deep Research: Codebase Indexing Tools for AI Assistants"
tags:
  - claude-knowledge
  - deep-research
---

# Deep Research: Codebase Indexing Tools for AI Assistants

**Research Date**: 2026-02-18
**Confidence Level**: High
**Sources Consulted**: 28+

## Executive Summary

The codebase indexing landscape for AI assistants has matured significantly. There are three dominant paradigms: (1) **symbol-map / repo-map** approaches that extract function signatures and class definitions into a compact text representation (pioneered by aider, now available as standalone tools); (2) **semantic search / RAG** approaches that chunk code, embed it, and retrieve via vector similarity (Cursor, Continue.dev, Claude Context); and (3) **on-demand query servers** that index a codebase and let the LLM query for specific symbols/callers/implementations as needed (CodeRLM, Serena, Code-Index-MCP).

For Claude Code specifically, the most practical existing solutions are **RepoMapper** (standalone MCP server implementing aider's repo-map approach), **CodeRLM** (Rust server with a Claude Code skill for on-demand querying), **Code-Index-MCP** (48-language indexer with sub-100ms queries), and **Serena** (LSP-based semantic code intelligence). The "lightweight codebase map" approach -- extracting signatures only into a 5-10% token-size representation -- is the most token-efficient and can be generated with tree-sitter in seconds for medium codebases.

Incremental indexing is supported by several tools (Code-Index-MCP via file watchers, Cursor via Merkle trees, CocoIndex via change detection) but aider's repo-map notably does NOT cache well and regenerates frequently. The most mature incremental approach is Sourcegraph's SCIP protocol, which achieves 10x speedups by indexing only changed files.

## Key Findings

### 1. Aider's Repo-Map: The Pioneer

**How it works:**
- Uses tree-sitter to parse every file in the git repo into ASTs
- Extracts symbol definitions (functions, classes, methods) and references
- Builds a dependency graph where files are nodes and edges represent cross-references
- Applies **PageRank algorithm** to rank files and symbols by importance
- Selects the most important symbols that fit within a configurable **token budget** (default: 1,024 tokens)
- Output format shows file paths with indented signatures and ellipsis markers for omitted content

**Example output format:**
```
aider/coders/base_coder.py:
...
|class Coder:
|    abs_fnames = None
...
|    @classmethod
|    def create(
|        self,
|        main_model,
```

**Incremental support:** Limited. Has a `--map-refresh` option with modes: auto, always, files, manual. The "files" mode refreshes only when files change, but users report it is still slow for large repos (1000+ files). No persistent caching across sessions. The `.aiderignore` file and `--subtree-only` flag are the main performance mitigation strategies.

**Token budget behavior:** Dynamic -- aider expands the repo map significantly when no files are added to chat, and shrinks it as files are explicitly included. This adaptive behavior is key to its effectiveness.

**Source:** [Aider repo-map docs](https://aider.chat/docs/repomap.html) | [Building a better repo map with tree-sitter](https://aider.chat/2023/10/22/repomap.html)

### 2. Standalone Tools That Generate Codebase Maps

#### RepoMapper (MCP Server)
- **GitHub:** https://github.com/pdavis68/RepoMapper
- **What:** Standalone extraction of aider's repo-map algorithm as both CLI tool and MCP server
- **Tech:** Tree-sitter + PageRank, 20+ languages, STDIO MCP transport
- **License:** MIT
- **Key advantage:** Drop-in MCP server for any AI assistant, including Claude Code
- **Incremental:** Not documented

#### Gitingest
- **GitHub:** https://github.com/coderamp-labs/gitingest
- **What:** Replace 'hub' with 'ingest' in any GitHub URL to get a prompt-friendly text extract
- **Approach:** Full file concatenation with smart filtering, not symbol extraction
- **Best for:** Quick one-shot context dumps, not ongoing development

#### Codebase-Digest
- **GitHub:** https://github.com/kamilstanuch/codebase-digest
- **What:** AI-friendly codebase packer with 60+ analysis prompts
- **Approach:** Structured overviews with metrics, full file content
- **Best for:** Initial codebase analysis, not lightweight ongoing indexing

#### Code Maps (Concept/Pattern)
- **Source:** [Code Maps article](https://origo.prose.sh/code-maps)
- **What:** "Signatures-only" representation: namespace declarations, public class/type definitions, method signatures, inheritance relationships
- **Token efficiency:** 5-10% of original code size captures 90% of architectural understanding
- **Generation:** Can use language-specific parsers (Python ast, JavaParser, TypeScript Compiler API, Roslyn, go/ast) or tree-sitter
- **RepoPrompt** is cited as the "gold standard" commercial implementation

### 3. On-Demand Query Servers (MCP/API)

#### CodeRLM
- **GitHub:** https://github.com/JaredStewart/coderlm
- **What:** Rust server + Claude Code skill implementing the Recursive Language Model pattern
- **Architecture:** Index -> Query -> Read. Server walks dirs (respects .gitignore), parses with tree-sitter, builds symbol tables with cross-references
- **Claude Code integration:** `/coderlm` skill with hooks for auto-initialization; structured workflow: init -> structure -> search -> impl -> callers -> synthesize
- **Languages:** Rust, Python, TypeScript, JavaScript, Go, Java, Scala (tree-sitter); SQL (regex fallback)
- **Key feature:** Zero Python dependencies for CLI; agents query for exactly what they need instead of loading everything
- **License:** MIT

#### Code-Index-MCP (ViperJuice)
- **GitHub:** https://github.com/ViperJuice/Code-Index-MCP
- **What:** Modular local-first code indexer as MCP server
- **Architecture:** FastAPI gateway -> dispatcher -> language plugins -> SQLite+FTS5 indexes
- **Performance:** Sub-100ms symbol lookup, <500ms search, <10s indexing for cached repos
- **Languages:** 48 languages via tree-sitter with dedicated plugins for Python, JS, TS, C, C++, Dart, HTML/CSS
- **Incremental:** Yes -- real-time file monitoring via watchdog + git synchronization
- **Semantic search:** Optional Voyage AI embeddings for hybrid BM25+vector search
- **Extras:** GitHub Artifacts for portable index sharing, smart result reranking
- **License:** MIT

#### Serena
- **GitHub:** https://github.com/oraios/serena
- **What:** Coding agent toolkit with semantic retrieval and editing via LSP
- **Architecture:** Built on Solid-LSP (custom multilspy wrapper), uses Language Server Protocol
- **Key difference:** Uses LSP instead of tree-sitter, giving true IDE-level understanding (type inference, go-to-definition, find references)
- **Tools:** `find_symbol`, `find_referencing_symbols`, `insert_after_symbol`
- **Languages:** 30+ via LSP
- **Integration:** MCP server, OpenAPI bridge, JetBrains plugin
- **Best for:** Large, structured projects where IDE-level precision matters

#### Claude Context (Zilliz)
- **GitHub:** https://github.com/zilliztech/claude-context
- **What:** Semantic code search MCP for Claude Code
- **Architecture:** Core indexing engine + VSCode extension + MCP server
- **Approach:** Hybrid BM25 + dense vector search with configurable embeddings (OpenAI, VoyageAI, Ollama, Gemini)
- **Performance claim:** ~40% token reduction vs equivalent retrieval quality
- **Languages:** 14 (TS, JS, Python, Java, C++, C#, Go, Rust, PHP, Ruby, Swift, Kotlin, Scala, Markdown)
- **Storage:** Zilliz Cloud vector DB

#### seu-claude
- **GitHub:** https://github.com/jardhel/seu-claude
- **What:** Local codebase RAG MCP server for Claude Code with proactive semantic indexing
- **Features:** AST-based perception via tree-sitter, persistent task DAG (SQLite), TDD validation loop, hypothesis engine

#### mcp-server-tree-sitter (wrale)
- **GitHub:** https://github.com/wrale/mcp-server-tree-sitter
- **What:** Generic MCP server wrapping tree-sitter for code analysis
- **Features:** AST access, symbol extraction, dependency analysis, parse tree caching, state persistence between invocations
- **Best for:** Building custom analysis on top of tree-sitter via MCP

### 4. How Major AI Editors Index Codebases

#### Cursor
- **Approach:** RAG with vector embeddings stored in Turbopuffer
- **Chunking:** AST-based splitting via tree-sitter to preserve semantic boundaries
- **Change detection:** Merkle tree of file hashes; every 10 minutes, checks for mismatches and re-embeds only changed files
- **Privacy:** File path obfuscation before transmission; actual code stays local
- **Performance:** Incremental updates only upload changed files; initial indexing speed not publicly documented

#### Continue.dev
- **Approach:** Embeddings-based retrieval + keyword search (ripgrep)
- **Chunking:** Tree-sitter AST parsing -- checks if file fits, otherwise extracts top-level functions/classes, checks individual fit, truncates sub-methods if needed
- **Embeddings:** Default local all-MiniLM-L6-v2, stored in ~/.continue/index; configurable to Ollama, HuggingFace, Voyage, OpenAI
- **Retrieval:** Vector DB retrieves 25 candidates, re-ranking selects top 5
- **Source:** [Continue.dev codebase embeddings docs](https://docs.continue.dev/walkthroughs/codebase-embeddings)

#### Windsurf Codemaps
- **Approach:** AI-generated hierarchical maps using SWE-1.5 or Claude Sonnet 4.5
- **Generation:** Agent scans repo, resolves symbols, builds hierarchical map with nodes for files/functions/execution traces
- **Key difference:** Uses LLM to annotate and explain the map, not just extract symbols
- **Format:** Visual + structured, with nodes linking directly to code locations
- **Use in context:** @-mentionable in Cascade conversations

#### Sourcegraph (SCIP)
- **Protocol:** SCIP (Source Code Intelligence Protocol) -- Protobuf schema with human-readable symbol IDs
- **Approach:** Compiler-pipeline-based indexing with full semantic analysis
- **Incremental:** Yes -- "only needs to index the files that have changed instead of the entire repository on every commit"
- **Performance:** 10x speedup when replacing lsif-node with scip-typescript
- **Key advantage:** True compiler-level precision for go-to-definition and find-references
- **Source:** [SCIP announcement](https://sourcegraph.com/blog/announcing-scip) | [GitHub](https://github.com/sourcegraph/scip)

### 5. Incremental/Differential Indexing Strategies

| Tool | Strategy | Granularity | Speed |
|------|----------|-------------|-------|
| **Cursor** | Merkle tree hash comparison | File-level, 10-min sync | Only changed files re-embedded |
| **Code-Index-MCP** | Watchdog file monitoring + git sync | File-level, real-time | Sub-100ms queries after update |
| **SCIP/Sourcegraph** | Per-file compiler analysis | File-level, per-commit | 10x faster than full rebuild |
| **CocoIndex** | Incremental processing pipeline | File-level, near-real-time | O(changes) not O(repository) |
| **Aider repo-map** | `--map-refresh files` mode | Full regeneration with filtering | Slow for large repos |
| **Continue.dev** | Not documented as incremental | Full re-embed on change | Depends on embedding provider |

**Best practice:** Git-aware indexing (detecting changed files since last indexed commit via `git diff --name-only`) combined with file-watcher for uncommitted changes provides the best balance of freshness and performance.

### 6. Performance and Freshness Tradeoffs

**Full rebuild costs:**
- Aider repo-map: Seconds for small repos (<100 files), minutes for large repos (1000+ files)
- Code-Index-MCP: <10s for cached repos
- Cursor initial index: Not publicly documented, but users report minutes for large codebases

**Incremental update costs:**
- File-level re-indexing with tree-sitter: Sub-second per file
- Embedding generation: 50-200ms per chunk depending on model and provider
- Merkle tree diff: Negligible

**Staleness tolerance:**
- **Structural maps** (signatures, class hierarchies): Can tolerate hours/days of staleness for architecture-level questions; become harmful when method signatures change
- **Semantic search indexes:** Should be refreshed within minutes; stale embeddings return irrelevant code
- **Symbol tables:** Most sensitive to staleness -- a renamed function or moved class causes incorrect tool use
- **Practical guidance from Lootbox:** 3-day cache expiration with git commit tracking for early invalidation is a reasonable default for structural maps

**The "cached codemap" pattern** (from Lootbox):
- Generate signatures-only representation
- Cache at `~/.lootbox/cache/codemaps/codemap-{repo}-{hash}.json`
- 3-day expiration + git commit hash tracking for invalidation
- Auto-inject into AI tool calls (deep-think, deep-research, code-review, etc.)
- Manual regeneration with `force: true`

### 7. Tree-Sitter Based Approaches Summary

Tree-sitter is the dominant parsing technology across nearly all tools:

| Tool | Tree-sitter Usage | Output |
|------|-------------------|--------|
| **Aider** | Parse ASTs -> extract definitions + references -> PageRank | Repo map text |
| **RepoMapper** | Same as aider, standalone | MCP tool responses |
| **CodeRLM** | Parse -> symbol table with cross-refs | JSON API responses |
| **Code-Index-MCP** | Parse -> SQLite+FTS5 index | MCP tool responses |
| **Continue.dev** | Parse -> AST-aware chunking for embeddings | Vector search results |
| **Cursor** | Parse -> AST-aware chunk boundaries | Vector search results |
| **CocoIndex** | Parse -> semantic chunks for embedding | Postgres+pgvector |
| **mcp-server-tree-sitter** | Direct AST access + queries | MCP tool responses |

**Key insight:** Tree-sitter is used for two distinct purposes: (1) **symbol extraction** for structural maps, and (2) **intelligent chunking** for embedding/RAG pipelines. The former produces compact, human-readable output; the latter produces vectors for semantic search. Both are valuable but serve different needs.

## Recommendations

### For Claude Code Specifically

1. **Immediate, low-effort option:** Install **RepoMapper** as an MCP server. It provides aider's proven repo-map approach with PageRank-based importance ranking. Works out of the box.

2. **Best on-demand query experience:** **CodeRLM** with its Claude Code skill. The structured workflow (init -> structure -> search -> impl -> callers) is explicitly designed for Claude Code and reduces context consumption by letting Claude query for specific symbols instead of loading everything.

3. **Most feature-rich indexer:** **Code-Index-MCP** (ViperJuice). 48 languages, sub-100ms queries, real-time file watching, optional semantic search. The most "production-ready" of the MCP indexing servers.

4. **For large/complex codebases:** **Serena** with LSP gives true IDE-level intelligence (type inference, go-to-definition, find-references across 30+ languages). Higher setup cost but most accurate for complex type hierarchies.

### For Building Your Own

If none of the above fit exactly, the most practical approach is:

1. Use tree-sitter to extract function/class signatures from all files
2. Generate a "signatures-only" map (5-10% of original token size)
3. Cache the map with git commit hash for invalidation
4. Inject it into CLAUDE.md or serve via a simple MCP tool
5. For incremental updates, use `git diff --name-only HEAD~1` to identify changed files and re-extract only those

This is essentially what aider does, minus the PageRank ranking. The PageRank step adds value for very large repos where you need to prioritize which symbols to include within a token budget.

## Conflicting Information

- **Lootbox codemap cache** uses 3-day expiration, but other sources suggest structural maps can go stale within hours if active development is happening. The right answer depends on the pace of development.
- **Code-Index-MCP** claims 48-language support via tree-sitter, but the dedicated plugin system only covers 7 core languages; the rest use "generic tree-sitter" parsing which may miss language-specific semantics.
- **Windsurf Codemaps** use an LLM to generate and annotate maps, which is fundamentally different from the tree-sitter extraction approach. It produces richer annotations but at much higher cost and latency.

## Knowledge Gaps

- No public benchmarks comparing indexing speed across tools on the same codebase
- Aider's repo-map does not publish cache hit/miss rates or incremental performance data
- No tool provides a definitive answer on "how stale is too stale" -- this likely depends on the specific codebase and query patterns
- Claude Code's own internal indexing strategy (for /init, for file search) is not publicly documented in detail
- No comprehensive comparison of retrieval quality (precision/recall) across these tools

## Sources

1. [Aider repo-map documentation](https://aider.chat/docs/repomap.html) - HIGH credibility
2. [Building a better repo map with tree-sitter (Aider blog)](https://aider.chat/2023/10/22/repomap.html) - HIGH credibility
3. [RepoMapper GitHub](https://github.com/pdavis68/RepoMapper) - MEDIUM credibility (community project)
4. [CodeRLM GitHub](https://github.com/JaredStewart/coderlm) - MEDIUM credibility (new project, well-documented)
5. [Code-Index-MCP GitHub](https://github.com/ViperJuice/Code-Index-MCP) - MEDIUM credibility (active development)
6. [Serena GitHub](https://github.com/oraios/serena) - MEDIUM credibility (novel LSP approach)
7. [Claude Context GitHub (Zilliz)](https://github.com/zilliztech/claude-context) - MEDIUM-HIGH (backed by Zilliz)
8. [seu-claude GitHub](https://github.com/jardhel/seu-claude) - LOW-MEDIUM (early stage)
9. [mcp-server-tree-sitter GitHub](https://github.com/wrale/mcp-server-tree-sitter) - MEDIUM credibility
10. [How Cursor Indexes Codebases Fast (Engineer's Codex)](https://read.engineerscodex.com/p/how-cursor-indexes-codebases-fast) - HIGH credibility
11. [Continue.dev codebase embeddings docs](https://docs.continue.dev/walkthroughs/codebase-embeddings) - HIGH credibility
12. [SCIP announcement (Sourcegraph)](https://sourcegraph.com/blog/announcing-scip) - HIGH credibility
13. [SCIP GitHub](https://github.com/sourcegraph/scip) - HIGH credibility
14. [Code Maps article](https://origo.prose.sh/code-maps) - MEDIUM credibility (well-reasoned blog post)
15. [Lootbox cached codemaps](https://gist.github.com/johnlindquist/00dd3f91e8683e41d4881b23b8d5cf05) - MEDIUM credibility (practitioner implementation)
16. [CocoIndex realtime codebase indexing](https://github.com/cocoindex-io/realtime-codebase-indexing) - MEDIUM credibility
17. [Windsurf Codemaps docs](https://docs.windsurf.com/windsurf/codemaps) - HIGH credibility
18. [Codebase-Digest GitHub](https://github.com/kamilstanuch/codebase-digest) - MEDIUM credibility
19. [Gitingest GitHub](https://github.com/coderamp-labs/gitingest) - MEDIUM credibility
20. [CodeGraph MCP (LobeHub)](https://lobehub.com/mcp/your-org-codegraph-mcp) - LOW-MEDIUM credibility
21. [Tree-sitter GitHub](https://github.com/tree-sitter/tree-sitter) - HIGH credibility
22. [HN: CodeRLM discussion](https://news.ycombinator.com/item?id=46974515) - MEDIUM credibility (community validation)

## Related Topics

- **Prompt caching with codebase context** -- if the structural map is stable, it can be cached via Anthropic's prompt caching to avoid re-sending tokens
- **CLAUDE.md optimization** -- injecting a compact codebase map into CLAUDE.md vs. serving it via MCP tool
- **LSP vs. tree-sitter tradeoffs** -- LSP gives compiler-level accuracy but requires language servers; tree-sitter is lighter but less precise
- **Multi-repo indexing** -- none of these tools handle cross-repository dependencies well
- **Embedding model selection** -- all-MiniLM-L6-v2 (local, free) vs. Voyage AI code embeddings (better quality, paid) for code search
