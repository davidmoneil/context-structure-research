---
created: 2026-02-18T10:30
updated: 2026-02-18T10:30
tags:
  - domain/ai
  - depth/deep
  - project/aiprojects
  - type/research
  - topic/memory-systems
  - topic/claude-code
---

# claude-mem vs AIProjects: Memory System Comparison

> **Research Date**: 2026-02-18
> **Source**: [github.com/thedotmack/claude-mem](https://github.com/thedotmack/claude-mem)
> **Purpose**: Evaluate whether features from claude-mem should be adopted into AIProjects
> **Verdict**: Cherry-pick 4 patterns. Do not install claude-mem itself.

---

## Executive Summary

**claude-mem** is a persistent memory system for Claude Code that automatically captures tool usage during sessions, compresses it using a secondary AI agent, and injects compressed context into future sessions. It is built as a Claude Code plugin with ~29,420 lines of TypeScript source and ~14,890 lines of tests.

**AIProjects** uses a fundamentally different approach: curated, human-guided context management via CLAUDE.md, hooks, session-state.md, a knowledge base, and auto-memory files. It has 12 interconnected subsystems managing memory, tasks, orchestration, skills, agents, and infrastructure monitoring.

The two projects solve overlapping but distinct problems. claude-mem is a single-purpose memory tool. AIProjects is an infrastructure hub where memory is one of many layers.

---

## Philosophy Comparison

| Dimension | claude-mem | AIProjects |
|:---|:---|:---|
| **Core Approach** | Automated AI observation | Curated human-guided context |
| **Design Philosophy** | "AI should compress its own memory" | "Orchestration and scaffolding > model intelligence" |
| **Cost Model** | ~2x API cost (observer subprocess per tool use) | Zero additional API cost |
| **Scope** | Single-purpose memory tool | Full infrastructure hub with memory as one layer |
| **Storage** | SQLite + ChromaDB vector database | Files + SQLite (Beads) + Memory MCP knowledge graph |
| **Capture Method** | Every tool use intercepted automatically | Manual session summaries + automated audit logging |
| **Retrieval** | Semantic vector search + FTS5 | Grep/glob on files + entity graph (Memory MCP) |

---

## claude-mem Architecture

### System Overview

```
[Claude Code Hooks] --> [CLI Adapters] --> [HTTP Worker Service] --> [SQLite + Chroma] --> [MCP Server]
     (capture)          (normalize)         (process + store)        (persist + search)     (query)
```

### Core Components

| Component | File | Purpose |
|:---|:---|:---|
| **Hooks** | `plugin/hooks/hooks.json` | 5 lifecycle hooks (SessionStart, UserPromptSubmit, PostToolUse, Stop) |
| **Worker** | `src/services/worker-service.ts` | Express HTTP daemon on port 37777 (~1,124 lines) |
| **Observer Agent** | `src/services/worker/SDKAgent.ts` | Spawns separate Claude subprocess to analyze tool usage |
| **Prompts** | `src/sdk/prompts.ts` | XML-based prompts for the observer agent |
| **Parser** | `src/sdk/parser.ts` | Parses XML observations from agent responses |
| **SQLite DB** | `src/services/sqlite/Database.ts` | WAL mode, 256MB mmap, 12 migrations |
| **ChromaDB Sync** | `src/services/sync/ChromaSync.ts` | Vector embeddings via all-MiniLM-L6-v2 (WASM backend) |
| **MCP Server** | `src/servers/mcp-server.ts` | 5 MCP tools for querying memory |
| **Search** | `src/services/worker/search/SearchOrchestrator.ts` | Strategy pattern: Chroma semantic -> SQLite FTS5 fallback |

### The Compression Pipeline (Key Innovation)

This is claude-mem's most interesting design:

```
Your Claude session                    claude-mem Worker (port 37777)
---------------------------------------------------------------
You edit a file --PostToolUse hook-->  Receives raw tool input/output
                                           |
                                           v
                                       Persists to pending_messages table
                                       (crash recovery)
                                           |
                                           v
                                       Spawns SEPARATE Claude subprocess
                                       (Agent SDK, zero tools allowed)
                                           |
                                           v
                                       Observer receives XML prompt:
                                       "Analyze what happened and extract
                                        structured observations"
                                           |
                                           v
                                       Returns compressed observation:
                                       {
                                         type: "code_change",
                                         title: "Fixed auth middleware",
                                         subtitle: "Added JWT expiry check",
                                         facts: ["JWT validation missing.."],
                                         narrative: "The auth middleware...",
                                         concepts: ["JWT", "auth"],
                                         files_modified: ["src/auth.ts"]
                                       }
```

**Raw tool output**: 500-2,000 tokens (full file contents, terminal output, diffs)
**Compressed observation**: 100-300 tokens (structured meaning)
**Compression ratio**: 5-10x, and it is *semantic* -- the AI understands what happened and extracts meaning, not just truncating text.

### Progressive Disclosure (Token Efficiency Pattern)

When a future session retrieves context, claude-mem uses 3 layers:

| Layer | What Returns | Token Cost | When Used |
|:---|:---|:---:|:---|
| **Index** | List of observation titles + types | ~50-100 tokens each | Always at session start |
| **Timeline** | Chronological context around a specific observation | ~200-300 tokens | On demand via search |
| **Full Detail** | Complete facts, narrative, concepts, files | ~500+ tokens | On demand when Claude needs specifics |

Instead of dumping 10,000 tokens of full observations, the session starts with ~1,000 tokens of index. Claude only drills deeper when relevant. This is a **10x token savings** on retrieval.

### Storage Tables

```
sdk_sessions          -- Session tracking (content_session_id, memory_session_id, project, status)
observations          -- Structured observations (type, title, subtitle, facts[], narrative, concepts[], files[])
session_summaries     -- Session summaries (request, investigated, learned, completed, next_steps)
user_prompts          -- Raw user prompts with FTS5 virtual table
pending_messages      -- Crash-recoverable work queue
schema_versions       -- Migration tracking
```

### Complete Feature List

1. Automatic context capture (every tool use intercepted via PostToolUse hook)
2. AI-powered compression (separate Claude subprocess analyzes tool usage)
3. Session summaries (automated on Stop hook: request, investigated, learned, completed, next_steps)
4. Context injection (SessionStart hook injects compressed history)
5. Progressive disclosure (3-layer search: index -> timeline -> full details)
6. Semantic search (ChromaDB + all-MiniLM-L6-v2 WASM embeddings)
7. FTS5 full-text search (SQLite FTS5 on user prompts)
8. Web viewer UI (React SPA at localhost:37777 with real-time SSE updates)
9. MCP tools (5 tools: search, timeline, get_observations, save_memory, __IMPORTANT)
10. Privacy tags (`<private>` tags exclude sensitive content from storage)
11. Folder-level CLAUDE.md (auto-generates per-subdirectory CLAUDE.md files)
12. Multi-provider support (Claude SDK, Gemini, OpenRouter with fallback chain)
13. Mode system (configurable observation types/prompts per use case)
14. Mode inheritance (e.g., `code--ko` inherits from `code`, overrides for Korean)
15. Cursor IDE integration (hooks for Cursor via MCP config)
16. Session crash recovery (pending message queue with claim-confirm pattern)
17. Zombie process prevention (orphan reaper cleans up Claude subprocesses every 5 min)
18. Version auto-upgrade (worker auto-restarts on version mismatch)
19. Export/import (scripts for exporting and importing memories)
20. Interactive CLI installer (@clack/prompts based)
21. Bug report generator (automated diagnostic collection)
22. Git worktree support (worktrees share context via parent project detection)
23. 30+ language README translations

### Dependencies

**Runtime**: Bun, Python/uv (for ChromaDB), Node.js >= 18, Express, React, @anthropic-ai/claude-agent-sdk, @modelcontextprotocol/sdk, chromadb, handlebars, yaml, zod

**Setup complexity**: Medium-high. Auto-installs Bun and uv, manages background daemon, runs local ChromaDB. 40+ bug reports in docs suggest real-world fragility.

---

## AIProjects Memory Architecture

### System Overview

AIProjects uses 12 interconnected subsystems:

```
SESSION START
  session-start.js hook
    |-- Reads session-state.md (truncated to 2000 chars)
    |-- Reads current-priorities.md (truncated to 1500 chars)
    |-- Injects git branch and uncommitted changes count
    '-- Injects last session commit summary

CLAUDE.md LOADED (automatic)
    |-- References 30+ context files via @-imports
    |-- MEMORY.md injected into system prompt
    '-- voice-of-david.md behavioral rules active

DURING SESSION
    |-- orchestration-detector.js scores complexity
    |-- skill-router.js matches commands to skills
    |-- audit-logger.js logs every tool execution
    |-- self-correction-capture.js catches corrections
    |-- doc-sync-trigger.js watches for code changes
    '-- secret-scanner.js blocks secrets in commits

CONTEXT COMPACTION (when window fills)
  pre-compact.js hook
    |-- Injects full compaction-essentials.md
    '-- Preserves recent blockers

SESSION END ("end session")
    |-- Update session-state.md (status, summary, next steps)
    |-- Beads: close completed tasks, create follow-ups
    |-- Commit and push changes
    '-- Note blockers for next session

BETWEEN SESSIONS (automated)
  dispatcher.sh (cron every 5 min)
    |-- health-summary, upgrade-discover, abs-librarian
    '-- doc-sync-check, backup-validate
```

### Subsystem Inventory

| System | Files | Size | Key Metric |
|:---|:---:|:---:|:---|
| Auto Memory | 3 | ~16 KB | MEMORY.md always in system prompt; voice-of-david.md behavioral contract |
| Context | 205 | 2.4 MB | 17 subdirectories, 4-stage lifecycle (Discovery -> Doc -> Context -> Automation) |
| Session State | 1 | 41 KB | 29 session summaries, checked at every session start/end |
| Knowledge Base | 113 | 1.7 MB | Docs, notes, n8n workflows, MCP reference |
| Hooks | 42 | 396 KB | 16 registered (audit, security, workflow, lifecycle) |
| Skills | 14 | varies | 78 slash commands across structured-planning, parallel-dev, etc. |
| Beads Tasks | 7+ | varies | 110 issues, 796 events, SQLite + JSONL |
| CLAUDE.md | 1 | 31 KB | ~650 lines, 20 sections, the master instruction file |
| Paths Registry | 1 | 52 KB | 16 projects, 25+ containers, 5 hosts |
| Orchestration | 12 | varies | 11 active YAML plans with phases/dependencies |
| Agents | 15 | varies | 9 with persistent learnings.json |
| Logs | 1,376 | 20 MB | Audit, corrections, agent activity (Loki-ready JSONL) |

---

## Feature-by-Feature Comparison

### Memory Capture

| Capability | claude-mem | AIProjects |
|:---|:---:|:---:|
| Automatic tool use capture | :white_check_mark: | :yellow_circle: Audit log (raw events only) |
| AI-powered compression of observations | :white_check_mark: | :x: |
| Automated session summaries | :white_check_mark: | :yellow_circle: Manual during exit procedure |
| User correction capture | :x: | :white_check_mark: self-correction-capture.js |
| Privacy exclusion tags | :white_check_mark: `<private>` | :x: |
| Documentation drift detection | :x: | :white_check_mark: doc-sync-trigger.js |
| Cross-project commit tracking | :x: | :white_check_mark: cross-project-commit-tracker.js |

### Memory Storage

| Capability | claude-mem | AIProjects |
|:---|:---:|:---:|
| Structured observation DB | :white_check_mark: SQLite tables | :x: |
| Vector embeddings | :white_check_mark: ChromaDB | :x: |
| Knowledge graph | :x: | :white_check_mark: Memory MCP (entities, relations) |
| File-based context | :yellow_circle: Folder CLAUDE.md only | :white_check_mark: 205 context files, 2.4 MB |
| Session state tracking | :white_check_mark: sdk_sessions table | :white_check_mark: session-state.md (41 KB) |
| Task database | :x: | :white_check_mark: Beads (SQLite + JSONL, labeled, provenanced) |

### Memory Retrieval

| Capability | claude-mem | AIProjects |
|:---|:---:|:---:|
| Semantic vector search | :white_check_mark: ChromaDB + MiniLM | :x: |
| Full-text search | :white_check_mark: FTS5 on prompts | :yellow_circle: grep/glob on files |
| Progressive disclosure (token-efficient) | :white_check_mark: 3-layer index/timeline/detail | :x: |
| Context injection at session start | :white_check_mark: Compressed history | :white_check_mark: session-state + priorities |
| Compaction survival | :x: | :white_check_mark: pre-compact.js injects essentials |
| Knowledge graph queries | :x: | :white_check_mark: Memory MCP (9 tools) |

### Beyond Memory

| Capability | claude-mem | AIProjects |
|:---|:---:|:---:|
| Task management | :x: | :white_check_mark: Beads (CLI + TUI + labels + provenance) |
| Multi-phase orchestration | :x: | :white_check_mark: YAML plans with dependencies |
| Skills/workflow automation | :x: | :white_check_mark: 78 slash commands, 14 skills |
| Custom agents with persistent memory | :x: | :white_check_mark: 15 agents, 9 with learnings.json |
| Scheduled autonomous jobs | :x: | :white_check_mark: Headless Claude + cron dispatcher |
| Infrastructure monitoring | :x: | :white_check_mark: Health checks, container discovery |
| Security hooks | :x: | :white_check_mark: Secret scanner, branch protection |
| Behavioral contract (voice/style) | :x: | :white_check_mark: voice-of-david.md + MEMORY.md |
| Project registry | :x: | :white_check_mark: paths-registry.yaml (16 projects, 25+ containers) |
| Documentation lifecycle | :x: | :white_check_mark: 4-stage promotion pipeline |
| Web viewer UI | :white_check_mark: React SPA + SSE | :x: (bv TUI for tasks, Grafana for logs) |
| Multi-IDE support | :white_check_mark: Claude Code + Cursor | :x: Claude Code only |
| Multi-provider fallback | :white_check_mark: Claude/Gemini/OpenRouter | :x: Claude only |

---

## Code Quality Assessment: claude-mem

### Strengths

- **Error handling philosophy**: Exit 0 for graceful degradation, exit 2 for bugs. Worker unavailability never blocks the user.
- **Self-healing patterns**: `PendingMessageStore.claimNextMessage()` atomically resets stale processing messages before claiming. Eliminates stuck messages without timers.
- **Good test coverage**: 53 test files, ~14,890 lines of tests across SQLite, search, infrastructure, worker agents, and integration.
- **Defensive coding**: ReDoS protection in tag stripping, path injection validation in CLAUDE.md utils.
- **Structured logging**: Custom logger with components (SDK, DB, QUEUE, CHROMA) and structured context objects.

### Concerns

- **Crypto token ($CMEM)**: README starts with links to a Solana token (DEXScreener, Jupiter, Bags.fm). Significant red flag for an open-source developer tool.
- **Deprecated code coexisting with replacement**: Both `ClaudeMemDatabase` (new) and `DatabaseManager` (deprecated singleton) exist. Deprecated one is still the primary code path.
- **SQL interpolation**: ChromaSync directly interpolates observation IDs into SQL rather than using parameterized queries (low risk since IDs come from own DB, but still a pattern concern).
- **Version mismatch**: README says "6.5.0", package.json says "10.2.5". Hardcoded badges.
- **Windows fragility**: Extensive platform-specific code and 6+ bug reports suggest problematic Windows support.
- **Commented-out validation**: Summary parser has commented-out field validation with emphatic developer notes instead of being deleted.

### Limitations

1. **Token cost**: Every observation requires a Claude API call. Roughly doubles API cost.
2. **Latency**: Observer agent adds processing delay (async, doesn't block user).
3. **Single machine**: No cloud sync or team sharing.
4. **Bun + Python dependencies**: Non-standard runtime requirements add friction.
5. **No selective forgetting**: Cannot easily delete specific observations or sessions.
6. **Project name scoping**: Memory scoped by directory basename. Same-name projects collide.
7. **Observer quality**: If Claude misinterprets tool output, the memory is wrong.
8. **No deduplication**: Reading the same file 10 times may generate 10 observations.

---

## Adoption Recommendations

### :white_check_mark: Recommend Adopting (4 Patterns)

#### 1. Automated Session Summaries (Low Effort)

**What**: A Stop hook that auto-generates structured session summaries into session-state.md.

**Why**: The 19-step manual exit procedure works but requires discipline. Automating the summary removes friction and ensures every session is captured even if exit is skipped.

**Format to adopt** (from claude-mem):
```
{
  request: "What the user was trying to accomplish",
  investigated: "What was explored/researched",
  learned: "Key discoveries and insights",
  completed: "What was actually done",
  next_steps: "What remains for future sessions"
}
```

**Implementation**: New Stop hook that reads audit.jsonl for the current session and generates a structured summary. Could use local Ollama via Fabric (zero API cost) or a simple template-based approach from the raw audit data.

#### 2. Progressive Disclosure Search (Medium Effort)

**What**: 3-layer retrieval: index of titles -> timeline context -> full details.

**Why**: When searching 205 context files (2.4 MB), returning full content wastes tokens. An index layer would let Claude find relevant files first, then read only what matters.

**Implementation**: Generate an index file (`.claude/context/_search-index.md`) that lists every context file with a 1-line description. Update automatically via doc-sync-trigger. Claude reads the index first, then uses Read on specific files.

#### 3. Structured Observation Format (Medium Effort)

**What**: Adopt claude-mem's observation schema: `{type, title, facts[], narrative, concepts[], files[]}`.

**Why**: The audit logger captures raw tool events but doesn't structure them into meaning. Structured observations would make the audit log searchable and useful for future context.

**Implementation**: Enhance audit-logger.js to output structured observations. Use local Ollama (via Fabric) for compression during session or as a batch headless job. Store in JSONL alongside raw audit data.

#### 4. Privacy Tags (Low Effort)

**What**: A `<private>` tag convention that tells hooks to exclude content from logging/memory.

**Why**: Simple safety mechanism. Low effort, immediate value for sessions touching sensitive configs or credentials.

**Implementation**: Add tag detection to audit-logger.js. If tool output contains `<private>...</private>`, strip that content before logging.

### :yellow_circle: Consider Later (Not Urgent)

| Feature | Potential Value | Concern |
|:---|:---|:---|
| Semantic vector search on context files | Better discovery across 205 files | Adds Python dependency; Memory MCP partially covers this |
| Crash-resilient message queue for hooks | Prevents lost observations on crashes | Over-engineering for file-based hooks that rarely fail |
| Folder-level CLAUDE.md generation | Per-subdirectory context in large repos | AIProjects is a hub, not a codebase. Less relevant here |
| Web viewer for observations | Visual exploration of memory | bv TUI + Grafana already cover this niche |

### :x: Do Not Adopt

| Feature | Reason |
|:---|:---|
| AI observer subprocess | Doubles API cost. Curated approach + audit logging is cheaper and more predictable |
| Bun runtime dependency | Non-standard runtime adds friction. Node.js hooks work fine |
| ChromaDB / Python dependency | Heavy infrastructure for search when file-based + Memory MCP is lighter |
| Multi-provider fallback | Committed to Claude ecosystem. Gemini/OpenRouter adds complexity for no benefit |
| React web viewer | bv TUI (zero tokens) and Grafana (Loki-ready logs) already serve this need |
| Full claude-mem installation | Would run alongside existing systems, creating conflicts and redundancy |

---

## Implementation Roadmap (If Adopting)

| Priority | Pattern | Effort | Dependencies |
|:---:|:---|:---:|:---|
| 1 | Privacy tags in audit-logger.js | Low (1 hour) | None |
| 2 | Automated session summaries (Stop hook) | Low-Medium (2-3 hours) | Fabric/Ollama or template approach |
| 3 | Progressive disclosure search index | Medium (3-4 hours) | doc-sync-trigger enhancement |
| 4 | Structured observation format | Medium (4-6 hours) | Fabric/Ollama for compression |

**Total estimated effort**: ~10-14 hours for all 4 patterns.
**API cost increase**: Zero if using local Ollama for compression. Minimal if using Claude for session summaries only.

---

## Key Architectural Insight

claude-mem's fundamental bet is that **AI should compress its own memory**. This is genuinely clever -- semantic compression preserves meaning while drastically reducing token cost.

AIProjects' fundamental bet is that **curated context + automated orchestration > raw memory volume**. The 650-line CLAUDE.md, the behavioral contract in voice-of-david.md, the 19-step exit procedure -- these represent *human judgment* about what matters.

The two approaches are complementary, not competing. The recommended adoption path takes claude-mem's best mechanical patterns (progressive disclosure, structured observations, automated summaries) and implements them within AIProjects' curated philosophy -- getting the automation benefits without the API cost or architectural complexity.

**Bottom line**: Don't install claude-mem. Cherry-pick the 4 recommended patterns. You get 80% of the value at 10% of the complexity.

---

## Source Material

- **claude-mem repository**: [github.com/thedotmack/claude-mem](https://github.com/thedotmack/claude-mem) (cloned to `~/Code/claude-mem/`)
- **claude-mem stats**: ~29,420 lines TypeScript source, ~14,890 lines tests, 1,400+ commits, version 10.2.5
- **AIProjects stats**: 205 context files (2.4 MB), 42 hooks (396 KB), 14 skills, 15 agents, 110 Beads issues
- **Analysis method**: Full code review of both projects via code-analyzer agents with parallel deep analysis
